# Network

  - [1. 인터넷 네트워크](#1-인터넷-네트워크)
    - 계층구조
      - 계층 구조가 필요한 이유
    - 인터넷 프로토콜 스택
    - OSI 모델
  - [2. 애플리케이션 계층](#2-애플리케이션-계층)
    - 애플리케이션 계층의 원리
    - DNS란?
    - DNS의 동작원리
    - P2P
  - [3. 트랜스포트 계층](#3-트랜스포트-계층)
    - 트랜스포트 계층의 역할
    - UDP와 TCP의 차이
    - TCP의 신뢰적인 데이터 전송이란?
    - 다중화와 역다중화
    - UDP
    - TCP
    - TCP는 GBN인가? SR인가?
    - TCP 흐름제어
    - TCP 3 way handshake


</br>

## 1. 인터넷 네트워크
### 계층구조 
#### 계층 구조가 필요한 이유
인터넷은 매우 복잡한 시스템이다.  
다양한 애플리케이션과 프로토콜, 여러 가지 종단 시스템과 종단 시스템 간의 연결, 라우터, 다양한 링크 수준의 매체가 존재한다. 인터넷이 이렇게 아주 복잡하다면, 네트워크 구조를 어떻게 조직하는가?를 먼저 알아야 한다.  
#### 계층 구조의 장점
계층 구조는 크고 복잡한 시스템의 잘 정의된 특정 부분을 논의할 수있게 해주고, 이러한 단순화는 매우 중요하다.  
시스템이 계층 구조를 가지면, 그 계층이 제공하는 서비스의 구현을 변경하는 것도 매우 쉬워진다. 한 계층이 상위 계층에 같은 서비스를 제공하고, 하위 계층의 서비스를 이용하는 한, 어떤 한 계층의 구현이 변하더라도 시스템의 나머지 부분은 변하지 않기 때문이다. 

### 인터넷 프로토콜 스택
인터넷 프로토콜 스택은 5계층으로 구성된다. top-down 방식으로 접근해보면, 아래의 순서와 같다.
1. 애플리케이션 계층  
  애플리케이션 계층 프로토콜은 여러 종단 시스템에 분산되어 있다.  
  한 종단 시스템에 있는 애플리케이션이 다른 종단 시스템에 있는 애플리케이션과 정보 패킷을 교환할때 이 프로토콜을 사용한다.  

2. 트랜스포트 계층  
  트랜스포트 계층은 클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공한다.  
  인터넷에는 TCP와 UDP라는 두가지 트랜스포트 프로토콜이 존재하고, 이들은 애플리케이션 계층 메시지를 전달한다.  

3. 네트워크 계층  
  네트워크 계층은 한 호스트에서 다른 호스트로 데이터그램을 라우팅하는 책임을 가지며, 목적지 호스트의 트랜스포트 계층으로 세그먼트를 운반하는 서비스를 제공한다.  
  IP 프로토콜이 네트워크 계층에 속하며, 다른 프로토콜은 존재하지 않기 떄문에 네트워크 계층을 가진 모든 인터넷 요소는 IP 프로토콜을 수행해야만 한다.  

4. 링크 계층  
  네트워크 계층은 출발지와 목적지 간 일련의 패킷 스위치를 통해 데이터그램을 라우트한다. 이때 네트워크 계층은 링크 계층 서비스에 의존한다.  
  링크 계층은 네트워크 계층의 데이터그램을 받아 경로상의 다음 노드로 전달한다. 다음 노드에 존재하는 링크 계층은 이 데이터그램을 상위 네트워크 계층으로 보낸다.

5. 물리 계층  
  물리 계층은 링크 계층의 프레임 내부의 각 비트를 한 노드에서 다음 노드로 전달시킨다.  
  이 계층의 프로토콜들은 실제 물리 전송 매체에 의존하며, 각 매체별로 비트는 다른 방식으로 반대편으로 이동한다.

### OSI 모델
OSI 모델은 인터넷 프로토콜 모델과 다르다. 그리고 이것은 인터넷 프로토콜이 유일한 프로토콜 스택이 아니라는 것을 알 수있게 해준다. ISO가 제안한 컴퓨터 네트워크가 7계층으로 구성되어야 한다는 제안이 OSI 7계층이고, 인터넷 프로토콜 모델의 틀로 사용되었다. OSI 7계층은 아래와 같이 구성되어 있다.
1. 애플리케이션 계층 
2. 프레젠테이션 계층 
3. 세션 계층 
4. 트랜스포트 계층 
5. 네트워크 계층 
6. 데이터 링크 계층
7. 물리 계층

인터넷 계층과의 차이는 프레젠테이션 계층, 세션 계층이다.  

<br>

## 2. 애플리케이션 계층
### 애플리케이션 계층의 원리
네트워크에서 애플리케이션 계층은 컴퓨터 네트워크가 존재하는 이유이다. 
대표적으로는 웹, P2P 파일 공유, VoIP, 게임, SMTP 등이 있다. 우리가 개발하는 웹이나 앱도 애플리케이션 계층에 속한다.  
<br>
중요한 것은 새로운 애플리케이션을 개발할때, 라우터나 링크 계층 스위치와 같이 네트워크 코어 장비에서 실행되는 소프트웨어를 작성할 필요가 없다는 점이다. 개발자는 네트워크 구조가 고정되어 있고, 애플리케이션에 특정 서비스 집합을 제공하기만 하면 된다. 이렇게 종단 시스템에만 애플리케이션 소프트웨어가 존재한다는 기본 설계는 인터넷 애플리케이션이 광대하고 빠르게 발전할 수있던 원동력이 되었다.

<br>
현대 네트워크 애플리케이션에서 사용되는 구조는 'Client-Server' 혹은 'P2P'이다. 이때 발생하는 통신은 운영체제 관점에서 실제 통신하는 것은 '프로세스'이다. 프로세스는 컴퓨터 네트워크를 통해 '메시지'를 교환하고 서로 통신한다.  
  
<br>
<br>
한대의 컴퓨터에는 여러 프로세스가 동작할 수있다. 따라서 우리는 각 메시지가 어떻게 특정 프로세스를 위한 메시지인지 판별할 수있는가?를 이해해야 한다. 
이는 '소켓'을 통해 가능하다. 각 프로세스는 '소켓'을 통해 네트워크로 메시지를 보내고 받을 수있다. 따라서 소켓이 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스라는 것을 알 수있다.     
<br>
<br>
IP 주소를 이용해 Server 컴퓨터로 메시지가 들어왔다고 가정을 해보자. 그러면 소켓은 이 메시지를 적절한 프로세스로 전달해야 한다. 그리고 이때 프로세스의 'Port' 번호가 사용된다. 소켓은 Port 번호를 이용해 수신 프로세스를 식별한다. 

<br>
<br>

### DNS란?
DNS는 대표적인 애플리케이션 계층에 속하는 애플리케이션이다. 우리는 자주 이용하는 웹사이트를 Domain Name을 활용해 접속하곤 한다. 이 웹사이트에 request를 보내는 방법은 이것뿐일까? 아니다. 해당 Domain Name과 매핑된 IP 주소로도 request를 보내 웹사이트에 접속할 수있다.

이 두가지 방법 중 Domain Name을 사용해서 웹사이트에 접속하는 이유는 간단하다. 더 쉽기 때문이다. 사용자에게는 의미없어 보이는 IP 주소를 외우기란 쉽지가 않다. 또한 IP 주소가 변경되는 경우도 많다.  

하지만, 컴퓨터의 입장에서 생각해보면, 이 문제는 그리 단순하지 않다. Domain Name은 서버 컴퓨터의 위치에 대한 정보를 숨기고 있다. 이러한 이유로 라우터는 목적지 주소로 Domain Name을 받으면 어디로 보낼지 혼란스러워 한다. 

사용자와 컴퓨터의 패러다임 충돌로 인해 DNS가 필요하다. 사용자는 Domain Name으로 Server를 찾기 희망하고, 컴퓨터는 IP 주소를 더 좋아한다. 이 두개의 식별자를 매핑하여 원하는 정보를 알려주는 것이 바로 DNS가 하는 역할이다. 

### DNS의 동작원리
DNS는 분산형 데이터베이스라고 볼 수 있다. 왜? DNS는 분산형으로 설계가 되었을까? 이 의문을 해결하는 방법은 간단하다. 중앙 집중형으로 DNS를 설계했을때 문제점이 무엇인지 이해하면 된다. 

<br> 

요즘은 정말 많은 Domain Name이 있다. 그리고 DNS는 이 Domain Name을 IP 주소로 변환하는 역할을 수행한다. 이 매핑 관계는 DNS의 Database에 저장될 것이다. 만약 하나의 DNS 서버가 모든 매핑 정보를 저장한다면 어떤일이 생길까?   

1. 서버의 고장 : 한대의 DNS 서버가 고장나면 모든 서비스가 중단된다.
2. 트래픽 양 : 한대의 DNS 서버가 모든 트래픽을 받고 처리해야 한다.
3. RTT : 물리적인 위치에 따라 DNS의 응답을 받는 시간이 달라질 수있다.
4. 유지관리 : 하나의 DB에 모든 레코드를 저장하면 DB는 매우 거대해지고 사용자를 등록할때마다 DB를 갱신해야 한다. 

위와같은 이유가 대표적이고, 한마디로 정리하면 '확장성'이 매우 떨어진다.
<br>
이러한 이유들로 DNS는 분산형으로 설계되었다. 어떠한 단일 DNS 서버도 인터넷에 있는 모든 호스트에 대한 매핑을 갖지 않는 대신에 DNS 서버 사이에 분산된다. DNS는 크게 3가지 유형이 존재한다.
<br>
1. 루트 DNS 서버
2. TLD DNS 서버
3. 책임 DNS 서버

client가 어떤 Domain Name과 매핑되는 IP 주소를 얻고 싶다고 가정하자. 이때 DNS 서버로 Domain Name을 담은 패킷을 전송하는데, 위의 유형의 순서대로 탐색을 진행한다. 루트 DNS 서버는 domain name을 분석해 매핑된 TLD DNS의 IP를 찾아 client에게 알려준다. client는 이제 요청을 TLD DNS에게 다시 보낸다. TLD는 domain name을 분석해 책임 DNS 서버의 IP 주소를 client에게 전송한다. client는 책임 DNS 서버에게 다시 domain name에 대해 물어보고, 책임 DNS 서버는 자신이 가지고 있던 정보를 활용해 서버의 IP 주소를 client에게 알려준다.

### P2P
P2P는 Client-Server 구조와 매우 다르다. 
<br>
대부분의 애플리케이션은 항상 켜져있는 기반 구조 서버에 상당히 의존하는 Client-Server 구조를 채택한다. 반면 P2P 구조는 항상 켜져 있는 기반구조 서버에 최소한으로 의존한다는 특징을 가진다. 대신, 호스트들이 연결되어 서로 직접 통신하는 구조이다.  
P2P 구조를 선택함으로써 얻을 수있는 장점은 서버에게 커다란 부하를 주지 않고, 서버의 분배 프로세스를 도울 수있다.

## 3. 트랜스포트 계층
### 트랜스포트 계층의 역할
애플리케이션 계층과 네트워크 계층 사이에 존재하는 트랜스포트 계층은 네트워크 구조의 핵심이다. 트랜스포트 계층을 아주 간단하게 정리하면 서로 다른 호스트에서 동작하는 애플리케이션 프로세스에게 직접 통신 서비스를 제공하는 역할을 수행한다.   
네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신을 제공하는 반면, 트랜스포트 계층은 프로세스들 사이의 논리적 통신을 제공하는 차이는 매우 중요하다.
<br>
<br>
또한 트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다.

### UDP와 TCP
UDP는 비신뢰적이고 비연결형인 서비스를 제공하는 반면, TCP는 신뢰적이고 연결형 서비스를 제공한다.

이 둘의 가장 기본적인 기능은 종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다.  
또 다른 공통점은 헤더에 오류 검출 필드를 포함함으로써 무결성 검사를 제공한다는 것이 있다. 이러한 최소한의 두가지 트랜스포트 계층 서비스는 UDP가 제공하는 유일한 두가지 서비스이다. 

<br>
반면 TCP는 몇가지 추가적인 서비스를 제공하는데, 대표적으로 신뢰적인 데이터 전달을 제공한다. 또 흐름제어와 혼잡제어는 UDP와 TCP를 구별하는 대표적인 특징이다.

<br>
<br>

### TCP의 신뢰적인 데이터 전송이란?
송신하는 프로세스가 보낸 데이터를 수신하는 프로세스가 정확하게 받는 것을 보장하며, 패킷의 순서도 보장된다.  
<br>


### 다중화와 역다중화
다중화, 역다중화는 네트워크 계층이 제공하는 '호스트-호스트' 전달 서비스를 '프로세스-프로세스' 전달 서비스로 확장하는 것이며 모든 컴퓨터 네트워크에서 필요하다.  
<br>
다중화와 역다중화는 두 가지 요구사항을 가지고 있다.  
1. 소켓은 유일한 식별자를 가진다.  
2. 세그먼트는 전달될 적절한 소켓을 가리키는 특별한 필드를 가진다.  

여기서 등장한 소켓은 네트워크 -> 프로세스, 프로세스 -> 네트워크로 데이터를 전달하는 출입구이다.  
트랜스포트 계층은 데이터를 직접 프로세스로 전달하지 않고 소켓에게 대신 전달한다.  
세그먼트의 필드는 어떤 소켓으로 데이터를 전달해야 하는지에 대한 정보를 가지고 있는 식별자이다.  

TCP와 UDP는 다중화 역다중화 과정도 다르다.  
UDP는 도착지 IP 주소, 포트 번호로 소켓을 식별하는 반면, TCP는 도착지, 출발지 IP 주소, 도착지, 출발지 포트 번호로 소켓을 식별한다. 

### UDP
UDP는 트랜스포트 계층 프로토콜이 할 수있는 최소 기능으로 동작한다. 최소 기능은 아래와 같다.  
1. 다중화/역다중화
2. 간단한 오류검사

이 둘을 제외하면 UDP는 IP에 아무것도 추가하지 않는다.  
UDP는 3-way handshake 과정이 없기 때문에 TCP 보다 빠르다. 그리고 이 핸드셰이크 과정의 공백이 UDP를 '비연결형'으로 만들어준다.  

UDP와 TCP 중 어느것이 더 뛰어나다고 말할 수없고, UDP의 특징은 아래와 같다.  

1. 애플리케이션 레벨에서 더 정교한 제어가 가능하다.
2. 연결 설정이 없다.
3. 연결 상태가 없다
4. 작은 패킷 오버헤드

UDP 세그먼트의 구조는 아래의 그림과 같다. 
<br>  

<img width="408" alt="image" src="https://user-images.githubusercontent.com/76645095/179386341-14748ea3-b340-4c7f-bd00-acb3f9e8c7f1.png">
<br>  
<br>  
UDP 헤더는 2바이트씩 구성된 4개의 필드를 가진다. 이 필드들은 앞서 언급했던 트랜스포트 계층의 최소 기능을 수행하기 위해 존재하는 필드이다.

여기서 포트 번호는 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해주고, 체크섬은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트에서 사용된다.  

### TCP
TCP는 신뢰적인 데이터 전송을 보장한다.  
신뢰적인 데이터 전송을 위해 TCP는 오류 검출, 재전송, 누적 확인응답, 타이머, 순서번호, 확인응답 번호를 위한 헤더 필드를 가진다.  

TCP는 프로세스가 데이터를 다른 프로세스에게 보내기전에 두 프로세스가 서로 '핸드셰이크'를 먼저 진행해야 하므로 '연결 지향형'의 특징을 가진다.  
핸드셰이크는 TCP 연결 설정의 일부로서, 연결된 종단은 TCP 연결과 연관된 많은 TCP 상태 변수를 초기화한다.  

주의할 것은 TCP 프로토콜은 오직 종단 시스템에서만 동작하고, 중간의 네트워크 요소에서는 동작하지 않으므로, 중간의 네트워크 요소들은 TCP 연결 상태를 유지하지 않는다.  
애초에 중간 라우터들은 네트워크 계층이기 때문에 TCP 연결을 감지조차 못한다.  

TCP 세그먼트 구조는 아래의 그림과 같다.  

<img width="861" alt="image" src="https://user-images.githubusercontent.com/76645095/179387217-ea7a8334-5aa9-4a3b-90c3-03468d27cf06.png">

<br>  
TCP 세그먼트는 헤더 필드와 데이터 필드로 구성되어 있다.  

<br>

TCP 헤더는 일반적으로 20바이트 이고, UDP 헤더보다 12바이트 크다.
<br>  
UDP처럼 헤더는 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는데 사용하는 '출발지'와 '목적지' 포트 번호를 포함한다.  
또한 UDP처럼 체크섬 필드도 포함하고 있는 것을 볼 수있다. 추가적인 필드는 아래와 같은 것들이 존재한다.  

- 순서번호 필드 + 확인 응답번호 필드 : 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해서 사용된다.  
- 수신 윈도우 : 흐름제어를 위해 사용된다.  
- 헤더 길이 : TCP 헤더의 길이를 나타낸다. 
- 옵션 필드 : 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하기 위해 사용된다. 
- 플래그 비트 : ACK, SYN, FIN, PSH 비트 등을 포함한다.

### TCP는 GBN인가? SR인가?

이 의문을 해결하기 위해서는 GBN과 SR에 대한 지식이 필요하다.
간략하게 이 둘은 네트워크에서 신뢰적인 전송을 위한 2가지 파이프라인 프로토콜이다.

rdt의 고전적인 문제는 stop-and-wait 방식을 사용하는 것인데, 패킷을 하나씩 보내고 확인응답을 받고 하며 동작하기 때문에 매우 성능이 낮다.

따라서 이 문제를 해결하기 위해 한번에 여러개의 패킷을 전송하는 파이프라인 프로토콜이 등장했고, 두가지 기법이 GBN, SR이다.

<br>
이 둘도 차이가 존재하는데, ACK의 의미가 우선 다르다.  
<br>
GBN의 ACK N은 seq N까지의 패킷을 받았다는 의미를 가진다. 또한 슬라이딩 윈도우 기법을 활용하며 하나의 패킷이라도 유실된다면 유지하고 있는 window size의 모든 패킷을 재전송한다. 때문에 이미 수신자 입장에서 받은 패킷도 재전송하는 문제가 발생하고, 그만큼 성능이 떨어진다.  

<br>
<br>

SR은 이 문제를 해결하기 위해 선택적으로 패킷에 대한 ACK를 전송하고, ACK N의 의미는 N번 패킷을 잘 받았다는 의미를 가진다. 또한 수신 버퍼를 유지하면서 이전에 받은 패킷을 저장한다.

만약 N번 패킷에 대해 timeout 이벤트가 발생한다면, SR은 딱 N번 패킷만 보낸다. 모든 패킷을 재전송하는 GBN과의 차이가 이부분이다.

<br>
그래서 TCP가 GBN인가? SR인가? 해결해야 한다.

결론부터 말하면, TCP는 GBN과 SR의 특징을 모두 활용하는 혼합된 형태이다.

<br>

TCP는 GBN의 ACK 방식을 활용하면서, SR의 수신자와 같이 수신 버퍼를 유지한다.


예를들어 송신자가 N과 N+1 패킷을 전송했다고 가정해보자.

송신자는 패킷을 보내고 타이머를 동작시킬 것이다. 이 패킷 N은 정상적으로 수신자에게 도착했지만, ACK N이 유실되었다. 그리고 수신자는 N+1 패킷도 받고, ACK N+1을 송신자에게 보낸다.


송신자는 이 상황에서 ACK N을 절대로 받지 못한다. 그런데 N번 패킷에 대한 timeout이 발생하기전 ACK N+1을 받는다면, TCP에서 송신자는 수신자가 N번 패킷까지 받았다고 판단한다. 그리고 N+2 패킷을 보낸다. 이는 GBN의 ACK 방식과 매우 유사하다.


만약 위의 상황과 달리 패킷 N에 대한 timeout이 발생했다면? GBN 방식대로라면 다시 모든 패킷을 전송할 것이다. 하지만, TCP는 딱 패킷 N만 다시 재전송하고, 수신자도 버퍼를 유지하고 있기에 정상적으로 모든 패킷을 받는다. 이는 SR의 동작 방식과 매우 유사해보인다.  
TCP는 GBN의 ACK 응답 방식을 사용하고, SR의 버퍼링 방식을 같이 사용하는 혼종이다. 왜? TCP는 이런 방식을 사용할까?  
<br>

GBN의 단점은 수신 버퍼가 존재하지 않아 모든 패킷을 보낸다는 것이고, SR의 단점은 모든 ACK 패킷을 확인한다는 것이다. 특히, SR은 수신자 입장에서 분명 ACK를 보냈는데 유실되면서 다시 ACK를 재전송해야 하는 문제가 생긴다. 이때 GBN을 결합하면 불필요한 패킷 재전송을 수행하지 않을 수있기 때문에, 이 둘을 적절히 혼합하면서 불필요한 패킷 재전송을 더욱 줄일 수있는 것이다.


### TCP 흐름제어
먼저 TCP는 흐름제어를 제공하고, UDP는 흐름제어를 제공하지 않는 점은 이 둘의 큰 차이 중 하나이다.  
TCP 연결의 각 종단에서 호스트들은 연결에 대한 개별 수신 버퍼를 설정한다. TCP 연결이 순서대로 올바르게 바이트를 수신할 때, TCP는 데이터를 수신 버퍼에 차곡차곡 저장한다.  
<br>
하지만, 이 버퍼의 크기는 한정적이다. 따라서 수신자가 버퍼를 읽는 속도가 송신자가 데이터를 전송하는 속도보다 느리다면, 수신 버퍼는 오버플로우가 발생할 것이다.
<br>
이렇게 송신자가 수신자의 버퍼를 오버플로우 시키는 것을 방지하기 위해서 TCP는 '흐름제어 서비스(flow-control service)'를 제공한다.  
<br>
이는 송신자의 데이터 전송 속도와 수신자가 버퍼를 읽는 속도를 일치시키는 목적을 가진 서비스이다.  
<br>
흐름제어와 혼잡제어의 목적은 분명히 다르지만, 동작하는 방식은 비슷하다.  
먼저 TCP는 흐름제어를 어떻게 제공하는지 살펴보자.  
<br> 

<img width="861" alt="image" src="https://user-images.githubusercontent.com/76645095/179387217-ea7a8334-5aa9-4a3b-90c3-03468d27cf06.png">

<br> 
위의 그림은 TCP 세그먼트의 구조이다.  
여기서 '수신 윈도우'는 수신 측에서 사용 가능한 버퍼 공간이 얼마나 되는지 송신자에게 알려주는 필드이고, 흐름제어에서 사용되는 필드이다.  
<br> 

송신자는 이 필드를 이용해 수신자에게 얼마의 버퍼 공간이 남았는지 계산할 수있다. 따라서 수신 버퍼에 overflow가 발생하기까지 얼마나 남았는지 확신할 수있고, 데이터 전송률을 조절한다.  
<br> 

하지만, 이 방법에는 문제가 있다. 만약 수신자의 남은 버퍼 공간이 0이라면? 송신자는 더이상 데이터를 보내지 않을 것이다. 
<br> 
송신자가 패킷을 보내지 않으면, 수신자의 버퍼 공간에 여유가 생긴다해도 송신자는 이 사실을 알 방법이 없다.  
<br> 
이 문제를 해결하기 위해 TCP 명세서는 수신자의 수신 윈도우가 0일때, 송신자는 1바이트의 더미 데이터를 계속해서 전송하도록 요구한다.  
그리고 송신자는 이 더미데이터에 들어있는 수신 윈도우의 값으로 수신자의 버퍼 공간을 확인한다.  

