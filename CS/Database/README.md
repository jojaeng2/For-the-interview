# Database

  - [1. Database 시스템의 개념](#1-database-시스템의-개념)
    - [데이터베이스의 개념 및 특징](#데이터베이스의-개념-및-특징)
      - [개념](#개념)
      - [특징](#특징)
    - [데이터베이스 시스템의 구성](#데이터베이스-시스템의-구성)
    - [데이터베이스를 사용하는 이유](#데이터베이스를-사용하는-이유)
  - [2. 관계 데이터 모델](#2-관계-데이터-모델)
    - [데이터 무결성이란?](#데이터-무결성이란)
    - [무결성 제약조건](#무결성-제약조건)
  - [3. 데이터베이스 정규화](#3-데이터베이스-정규화)
    - [이상현상의 정의](#이상현상의-정의)
    - [이상현상의 개념](#이상현상의-개념)
    - [정규화란](#정규화란)
    - [정규화 과정](#정규화-과정)
    - [무손실 분해](#무손실-분해)
  - [4. 트랜잭션](#4-트랜잭션)
    - [트랜잭션의 개념](#트랜잭션의-개념)
    - [트랜잭션은 왜 필요할까](#트랜잭션은-왜-필요할까)
    - [트랜잭션 VS 프로그램](#트랜잭션-vs-프로그램)
    - [ACID](#acid)
    - [원자성](#원자성)
    - [일관성](#일관성)
    - [고립성](#고립성)
    - [지속성](#지속성)
  - [5. 동시성 제어](#5-동시성-제어)
    - [동시성 제어란](#동시성-제어란)
    - [갱신손실 문제](#갱신손실-문제)
    - [락](#락)
  - [6. 회복](#6-회복)
    - [트랜잭션과 회복](#트랜잭션과-회복)
    - [로그 파일](#로그-파일)
    - [로그 파일을 이용한 회복](#로그-파일을-이용한-회복)
  - [7. DBMS가 동작하는 구조](#7-dbms가-동작하는-구조)
  - [8. 인덱스](#8-인덱스)


</br>

## 1. Database 시스템의 개념
### 데이터베이스의 개념 및 특징
#### 개념
데이터베이스는 각 조직에서 사용할 데이터를 통합하고 공유할 목적으로 구축된다. 기본적으로 사용되는 데이터베이스의 개념은 4가지로 설명할 수있다.

1. 통합된 데이터 (Integrated Data)   
  여러 곳에서 사용하던 데이터를 통합하여 하나로 저장한 데이터를 의미한다.
2. 저장된 데이터 (Stored Data)  
  디스크, 테이프 같은 컴퓨터 저장장치에 저장된 데이터를 의미한다. 
3. 운영 데이터 (Operational Data)  
  조직의 목적을 위해 사용되는 데이터를 의미한다. 조직의 목적과 관계없이 저장된 데이터나 단순 입출력 데이터같이 임시로 저장된 데이터는 운영 데이터에 속하지 않는다.
4. 공용 데이터 (Shared Data)  
  한 업무를 위해 사용되는 데이터가 아니라 공동으로 사용되는 데이터를 의미한다. 데이터는 어느 순간이라도 둘 이상의 프로그램 또는 여러 사람이 동시에 사용할 수있다.

#### 특징
1. 실시간 접근성 (Real Time Accessibility)  
  데이터 베이스는 실시간으로 서비스 된다.
2. 계속적인 변화 (Continuous Change)  
 데이터베이스에 저장된 내용은 어느 한 순간의 상태를 나타내지만, 데이터 값은 시간에 따라 항상 바뀐다.

3. 동시 공유 (Concurrent Sharing)  
 데이터 베이스는 서로 다른 업무 또는 여러 사용자에게 동시에 공유된다. 

4. 내용에 따른 참조 (Reference By Content)  
 데이터베이스에 저장된 데이터는 데이터의 물리적인 위치가 아니라 데이터 값에 따라 참조된다. 사용자는 원하는 데이터를 얻기 위해 데이터 값을 사용하여 데이터베이스에게 조건을 제시하고, 데이터베이스는 이에 해당하는 데이터를 검색한다.

### 데이터베이스 시스템의 구성
데이터베이스 시스템은 아래와 같은 3가지 요소로 구성된다.
1. DBMS  
  사용자와 데이터베이스를 연결시켜주는 소프트웨어로 주기억장치에 상주한다.
2. 데이터베이스  
  컴퓨터 내부의 물리적인 하드디스크를 말한다.
3. 데이터 모델  
  데이터가 저장되는 기법에 관한 내용으로 눈에 보이지 않는 논리적인 개념을 말한다.


### 데이터베이스를 사용하는 이유  
데이터를 저장하고 사용하는 방법은 다양하다. 그런데, 왜? 다양한 방법 중 데이터베이스를 사용하는가?에 대해 알아보자. 대표적인 데이터 저장 방법은 3가지가 존재한다.

1. 데이터를 프로그램 내부에 저장하는 방법  
  어떤 배열에 데이터를 저장해놓고, 이 데이터를 사용한다고 생각해보자. 코드를 컴파일하면 데이터를 사용하는 것은 문제가 되지 않는다. 하지만, 데이터가 추가된다면 코드를 수정하고 다시 컴파일해야 한다는 문제가 있다. 데이터의 추가나 삭제 같은 변경 작업이 없다면 아무 문제가 없지만 데이터는 항상 변경이 생기기 때문에 문제가 발생한다.
2. 파일 시스템을 사용하는 방법  
  데이터를 프로그램과 분리하여 별도의 파일에 저장하여 사용한다고 생각해보자. 이 방법의 문제는 데이터 구조가 변경될때 프로그램 내부에 데이터를 저장할때와 같은 문제가 생긴다.   
  또한 하나의 파일을 두개의 프로그램이 읽으려고 할때 문제가 생긴다. 

3. DBMS를 사용하는 방법  
  소프트웨어의 일종인 DBMS를 사용하면 앞의 두가지 문제를 전부 해결할 수있다.   
  DBMS는 데이터 정의, 데이터 변경 등의 작업을 할 수있는 별도의 프로그램을 가지고 있기 때문에 데이터 정의와 데이터 값을 DBMS가 관리할 수있다. 따라서 프로그램이 직접 다루는 데이터 정의가 바뀌지 않는 한, 다시 컴파일할 필요가 사라진다.


## 2. 관계 데이터 모델
### 데이터 무결성이란
데이터 무결성은 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것을 말한다. 일관성과 정확성을 잃어버린 데이터베이스는 정보로서의 가치에 심각한 문제가 있는 것이다.

### 무결성 제약조건
무결성 제약조건은 크게 3가지가 존재한다.

- 도메인 무결성 제약조건
  - 릴레이션 내의 튜플들이 각 속성의 도메인에 저장된 값만을 가져야 한다는 조건이다.
- 개체 무결성 제약조건
  - 기본키 제약이라고도 부른다.
  - 릴레이션은 기본키를 지정하고, 기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건이다.

- 참조 무결성 제약조건
  - 릴레이션간의 참조 관계를 선언하는 제약조건이다. 
  - 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다는 조건을 말한다.

## 3. 데이터베이스 정규화
### 이상현상의 정의
데이터베이스 테이블이 잘못 설계되면 삽입, 삭제, 수정 같은 데이터 조작을 하면 이상현상이 일어난다. 이상현상이란 테이블에 튜플을 삽입할 때 부득이하게 NULL 값이 입력되거나, 삭제시 연쇄 삭제 현상이 발생하거나, 수정 시 데이터의 일관성이 훼손되는 현상을 말한다.

<br>

### 이상현상의 개념
이상현상은 한 개의 릴레이션에 두 개 이상의 정보가 포함되어 있을때 주로 나타나고, 이상 현상이 발생하는 상황은 총 3가지가 존재한다.
1. 삭제이상  
튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상이다.
2. 삽입이상  
튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL 값을 입력해야 하는 현상이다.
3. 수정이상  
튜플 수정 시 중복된 데이터의 일부만 수정되어 테이터의 불일치 문제가 일어나는 현상이다.

### 정규화란
이상 현상은 대부분 두 가지 이상의 정보가 한 릴레이션에 저장되어 있을때 발생한다고 언급했다. 따라서 이상현상은 릴레이션을 분해하여 제거한다. 분해된 릴레이션에 이상현상이 남아 있다면, 이상현상이 없어질 때까지 분해하여 해결한다. 
<br>
<br>
이렇게 이상현상이 발생하는 릴레이션을 분해하여 이상현상을 없애는 과정을 '정규화(normalization)'라고 부른다. 

### 정규화 과정
릴레이션의 종속성 상황에 따라 여러 정규화 기법을 사용할 수있다. 대표적으로 4가지 정규화 기법이 존재하며, 정규형이 높을 수록 이상현상은 줄어든다.

1. 제 1 정규형  
모든 속성 값이 원자 값을 가지면 제 1 정규형을 만족했다고 부른다. 제 1 정규형을 만족하기 위해서는 릴레이션의 모든 속성 값이 원자값을 갖도록 변환하면 된다.

2. 제 2 정규형  
제 1 정규형을 만족하는 릴레이션의 기본키가 복합키일때, 복합키의 일부분이 다른 속성의 결정자인지 확인하고, 이를 만족한다면 제 2 정규형을 만족했다고 본다.   
예를들어, (A, B) -> R을 만족하는 릴레이션이 있다고 가정하자. 이때 종속성에서 B를 제거했는데 A -> R가 여전히 성립한다면, 제 2 정규화를 만족하지 못하는 상태인 것이다.

3. 제 3 정규화
제 3 정규형은 속성들이 '이행적'으로 종속되어 있는지 여부를 판단하는 것이다. 이행적 종속이란 릴레이션이 제 2 정규화를 만족하고, A -> B, B -> C가 성립할때 A -> C가 성립되는 함수 종속성을 말한다.

4. BCNF 정규화  
릴레이션에 존재하는 함수 종속성에서 모든 결정자가 후보키이면 BCNF 정규형이다.

### 무손실 분해
무손실 분해는 굉장히 간단하다.  
방금 위에서 4가지 정규화 기법을 살펴봤는데, 정규화 기법은 결국 릴레이션을 분해하여 이상현상을 제거하는 것이다. 릴레이션을 분해할 때는 지켜야 할 규칙이 있는데, 이 중 하나가 '무손실 분해'이다.  
분해된 릴레이션을 결국 다시 합쳐야 하고, 초기의 관계를 유지해야 한다. 따라서 릴레이션을 분해 했음에도 다시 조인했을때 원래의 릴레이션을 유지하는 것을 무손실 분해라고 한다. 즉, R을 R1, R2로 분해했을때, R1 + R2 = R을 다시 만족하도록 릴레이션을 분해하는 것을 말한다.


## 4. 트랜잭션
### 트랜잭션의 개념
트랜잭션은 DBMS에서 데이터를 다루는 논리적인 작업의 단위를 말한다.  
<br>

### 트랜잭션은 왜 필요할까
1. 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우가 생긴다. 트랜잭션은 이러한 장애가 발생할때 데이터를 복구하는 작업의 단위가 된다.
2. 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 있다. 트랜잭션은 이 작업을 서로 분리하는 단위가 된다.  


트랜잭션의 가장 중요한 포인트는 전체가 수행되거나 또는 전혀 수행되지 않아야 한다는 것이다. 예를들어 우리가 친구에게 송금을 하는 상황을 상상해보자.  
이때 송금이 이뤄지는 과정은 아래의 순서와 같이 이뤄질 것이다.  

(1) 나의 계좌에서 금액을 뺀다.
(2) 친구의 계좌에 금액을 더한다.

이때 (2)를 진행하던 중 에러가 발생했다고 한다. 그러면 친구는 돈을 받지 못했을 것이고, 내 은행 계좌에서는 금액이 인출되었을 것이다. 

이러한 이유로 트랜잭션은 필요하고, 전체가 수행되거나 수행되지 않아야 하는 이유를 납득할 수있을 것이다.

<br>

### 트랜잭션 VS 프로그램
트랜잭션은 일반 프로그램과 달리 데이터베이스에 저장된 데이터를 다루며, DBMS에 의해 처리된다. 반면, 프로그램은 파일에 저장된 데이터를 다루며 DBMS 없이 직접 데이터를 처리한다.

### ACID
ACID는 트랜잭션의 4가지 성질을 정리한 것이다. 영문 앞 글자를 따서 보통 ACID 성질이라고 부른다.
간략하게 ACID를 하나씩 살펴보자.
1. 원자성(Atomicity)  
트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
2. 일관성(Consistency)  
트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
3. 고립성(Isolation)  
수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하는 일이 없어야 한다.
4. 지속성(Durability)  
수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다. 저장된 데이터베이스는 저장 직후 혹은 어느때나 발생할 수있는 장애에 영향을 받지 않아야 한다.


### 원자성
트랜잭션의 원자성이란 트랜잭션이 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다는 의미이다. 즉, 일부만 수행되는 일이 없도록 전부 수행하거나 아예 수행하지 않아야 한다. SQL에서는 트랜잭션의 시작과 끝을 표시하기 위해 START TRANSACTION ... COMMIT 문을 사용하기도 한다.  

트랜잭션 중간에 작업이 잘못되면 회복 알고리즘을 이용하여 변경한 내용을 취소한다.

이때 트랜잭션의 길이가 너무 길면 트랜잭션의 중간 지점에 수정 내용을 반영하는 포인트를 만드는데, 이를 SAVEPOINT(저장점)이라고 부른다.  

SAVEPOINT를 사용하는데, 트랜잭션이 잘못되어 처음부터 다시 실행해야 할 경우 트랜잭션의 처음이 아니라 SAVEPOINT까지 되돌아가면 트랜잭션 전체가 ROLLBACK 되는 것을 막을 수있다.  

### 일관성
트랜잭션은 데이터베이스의 '일관성'을 유지해야 한다. 일관성은 테이블이 생성될 때 CREATE 문과 ALTER 문의 무결성 제약조건을 통해 명시된다. 트랜잭션은 이 조건에 따라 일관성을 유지한다. 

### 고립성
데이터베이스는 공유가 목적이기 때문에 여러 트랜잭션이 동시에 수행된다. 이때 각 트랜잭션은 다른 트랜잭션의 방해를 받지 않고 독립적으로 작업을 수행한다. 이렇게 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상을 '고립성'이라고 한다. 고립성을 유지하기 위해서는 변경중인 임시 데이터를 다른 트랜잭션이 읽거나 쓰려고 할때 제어하는 작업이 필요하다.  

### 지속성
트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야 한다. DBMS 복구 시스템은 트랜잭션이 작업한 내용을 수시로 로그 데이터베이스에 기록했다가, 문제가 발생하면 로그 파일을 이용하여 복구 작업을 수행한다. 즉 시스템이 멈춰도 트랜잭션 수행으로 변경된 내용은 디스크에 기록된다.
<br>

## 5. 동시성 제어
### 동시성 제어란  
자동차 전용도로에 시간차를 충분히 두고 차를 진입시키면 충돌 사고가 발생하지 않는다.  
그러나 차를 제어하지 않고 임의로 진입시키면 충돌 사고가 발생할 수있다.  
<br>
트랜잭션도 마찬가지이다. 한 개의 트랜잭션이 끝나고 다음 트랜잭션을 수행시키면 데이터베이스의 일관성에 문제가 없다.  
그러나 데이터베이스는 공유를 목적으로 하기 때문에 가능한 많은 트랜잭션을 동시에 수행시켜야 한다. 이때 동시에 수행되는 트랜잭션은 다른 트랜잭션이 같은 데이터를 공유하고 있다는 사실을 모를 수있기 때문에 일관성이 훼손될 수있다.  
<br>
그리고 이렇게 트랜잭션이 동시에 수행되는 상황에서 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고 부른다.  
<br>

### 갱신손실 문제
갱신손실 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생한다. 갱신손실 문제는 데이터베이스에서 절대 발생하면 안되는 문제 중 하나이다.  
<br>
트랜잭션을 수행할때 하드웨어적으로 생각을 해보자.  
트랜잭션이 작업을 수행할때 데이터베이스에 저장된 데이터 값은 일단 주기억장치의 버퍼로 가져와야 읽을 수있다.  
즉, 트랜잭션은 버퍼에 저장된 데이터로 작업을 진행한다. 그리고 나중에 버퍼의 내용을 데이터베이스에 기록하는 작업은 DBMS가 수행한다.  

동시에 T1, T2이 같은 데이터에 대해 쓰기 작업을 수행한다고 가정하자. 그러면 메인메모리 버퍼로 해당 데이터를 가져오고 버퍼에 저장된 데이터를 이용해 작업을 수행할 것이다.  
이때 T1의 작업 시간이 T2 보다 훨씬 길다고 가정한다. T1이 먼저 데이터를 가져가 작업을 수행하는 상황에서, T2가 작업을 시작하고 종료했다면, T1의 작업이 갱신되지 않은 값을 T2는 작업할 것이다.  
T1의 입장에서는 이 사실을 모르고 작업을 종료해 데이터를 덮어씌운다. 그러면 T2의 작업은 무시되고 이것이 갱신손실 문제이다.  
 
### 락
갱신손실 문제를 해결하려면, 다른 트랜잭션이 데이터를 사용하는지 여부를 알 수있는 규칙이 추가되면 된다.  
<br>
즉, 자신이 작업중인 사실을 다른 트랜잭션에게 알릴 수있는 방법이 필요한데, 이 방법으로 '락'을 사용한다.  

락은 운영체제의 락과 같은 개념이다.  
데이터베이스에서 락은 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치이다. 락을 사용하여 자신이 사용할 데이터를 잠그면, 다른 트랜잭션은 잠금이 풀릴때까지 대기해야 한다.  

락을 사용하면, 데이터 X에 대한 갱신을 순차적으로 진행할 수있기 때문에 갱신손실 문제를 해결할 수있다.  

## 6. 회복
회복은 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능이다.  
### 트랜잭션과 회복
트랜잭션은 데이터베이스 회복의 단위이다. 트랜잭션은 데이터의 변경 내용을 한순간에 모두 데이터베이스에 기록하지 않는다. 대신, 일단 변경한 내용을 로그에 기록한 후 데이터베이스에 반영한다.  
<br>
DBMS의 회복 관리자는 트랜잭션의 ACID 성질 중 원자성(A)과 지속성(D)을 보장하여 장애로부터 데이터베이스를 보호한다.  

### 로그 파일
DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 트랜잭션의 데이터베이스 기록을 추적하는 '로그 파일'을 사용한다.  
로그 파일은 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록 해두는 별도의 데이터베이스이다. 안전한 하드디스크에 저장되며 전원과 관계없이 기록이 남아있다.  

### 로그 파일을 이용한 회복
데이터의 변경 기록을 저장해 둔 로그 파일을 이용하면, 시스템 장애도 복구할 수있으며, 로그를 이용한 회복 방법은 다음과 같다.  
<br>

시스템 운영 중 장애가 발생하여 시스템이 다시 가동되었을 때 DBMS는 로그 파일을 먼저 살펴본다.  
DBMS는 트랜잭션이 종료되었는지 혹은 중단되었는지 여부를 판단하여 종료된 트랜잭션은 종료를 확정하기 위하여 '재실행(REDO)'을 진행하고, 중단된 트랜잭션은 없던 일로 되돌리기 위해 '취소(UNDO)'를 진행한다.  
이 두 작업은 트랜잭션이 로그 데이터베이스에 기록한 모든 값에 대하여 (변경 전 값, 변경 후 값) 중 어느 하나를 데이터베이스에 맞는 값으로 수정하는 작업이다.  

## 7. DBMS가 동작하는 구조
DBMS는 사용자가 만든 테이블을 저장 장치에 저장하고 필요에 따라 검색하여 결과를 보여준다. 그렇다면, DBMS는 어떻게 저장과 검색을 할까??  

DBMS는 데이터를 DBMS만의 고유한 방식으로 저장하여 관리한다.  
<br>
![image](https://user-images.githubusercontent.com/76645095/179164218-d7428486-2d8f-4380-a8a5-a0fe8c910f40.png)

<br>
위의 그림은 DBMS의 질의 처리 과정을 나타낸 그림이다. DBMS도 운영체제에서 실행되는 응용 프로그램의 일종이다.  
<br>
<br>
그림을 보면, SQL 작업 TOOL을 통해 SQL 문을 작성하여 실행하면 DBMS에 의해 처리 방법이 결정되고, 운영체제를 통해 각 장치에 명령이 내려져 작업이 처리된다.  

저장 과정도 마찬가지 과정으로 진행되며 최종적으로 운영체제의 파일 시스템에 종속적인 데이터베이스 파일로 저장된다.  
<br>
이 과정에서 주의 깊게 살펴볼 점은 실제 데이터가 저장되는 곳이 보조기억장치라는 사실이다.  
보조기억장치는 일반적으로 하드디스크, SSD, USB 메모리 등을 들 수 있는데, 가장 많이 사용되는 장치는 하드디스크이다.  
<br>
하드디스크는 데이터를 읽어오기 위해 액세스 시간이 필요한데, 이 액세스 시간은 데이터의 저장 및 읽기에 많은 영향을 끼친다.  
<br>
DBMS가 하드디스크에 데이터를 저장하고 읽어올 때는 근본적인 속도 문제가 발생할 수밖에 없다. 컴퓨터 시스템에서 처리되는 연산 속도는 빠른데, 디스크는 기계 장치이기 때문에 액세스 속도가 느리기 때문이다.  
이러한 속도 문제를 줄이기 위해 주기억장치에 DBMS가 사용하는 공간 중 일부를 버퍼 풀로 만들어 사용하는 방법이 있다.  
DB는 버퍼에 자주 사용하는 데이터를 저장해두며 LRU(Least Recently Used) 알고리즘을 이용하여 사용빈도가 높은 데이터 위주로 저장하고 관리한다.  

## 8. 인덱스
인덱스는 자료를 쉽고 빠르게 찾을 수있도록 만든 데이터 구조이다. 도서관에서 책을 찾을때, 서지목록을 보고 책의 위치를 찾는 것처럼 인덱스도 같은 역할을 한다.  
<br>
데이터베이스 인덱스란? 원하는 데이터를 빨리 찾기 위해 튜플의 키 값에 대한 물리적 위치를 기록해둔 자료구조이다.  
일반적인 DBMS의 인덱스는 대부분 B-tree 구조로 되어 있다. B-tree에 대한 내용은 [자료구조](https://github.com/jojaeng2/Preparing-for-the-interview/tree/main/CS/DataStructure) 파트에 정리를 해놨으니 인덱스의 특징을 알아보자.  

B-tree 에서 검색은 루트 노드에서부터 값을 비교하여 중간 단계인 내부 노드에서 해당 노드를 찾고, 이런 단계를 거쳐 최종적으로 마지막 레벨인 리프 노드에 도달한다.  
리프 노드에서는 해당 데이터의 저장 위치에 대응하는 rowID(테이블의 행에 대한 논리적 위치)를 가지고 있어 찾고자 하는 행을 바로 찾을 수있다.  
<br>
B-tree는 데이터를 검색할 때 특유의 트리 구조를 이용하기 때문에 한 번 검색할 때마다 검색 대상이 줄어 접근 시간이 적게 걸린다.  
약 100만 개의 튜플을 가진 데이터도 3~4번의 디스크 블록을 읽으면 찾을 수있다.  
이러한 특징 때문에 주요 DBMS에서는 인덱스의 기본 구조로 B-tree를 많이 사용한다. 하지만, 데이터의 변경이나 추가가 잦을 경우 B-tree의 모양을 유지하기 위해 노드의 분할 및 이동이 자주 발생하는 문제가 존재한다.  
<br>
인덱스의 특징을 정리하면 아래와 같다.  
- 인덱스는 테이블에서 한 개 이상의 속성을 이용하여 생성한다.  
- 빠른 검색과 함께 효율적인 레코드 접근이 가능하다.
- 순서대로 정렬된 속성과 데이터의 위치만 보유하므로 테이블보다 작은 공간을 차지한다.
- 저장된 값들은 테이블의 부분집합이 된다.
- 일반적으로 B-tree 형태의 구조를 가진다.
- 데이터의 수정, 삭제 등의 변경이 발생하면 인덱스의 재구성이 필요하다.  

마지막으로 인덱스는 인덱스와 데이터 파일의 구조적인 특징으로 인해 특정 키 값을 찾는 검색의 경우 성능을 보장할 수있으나, 범위 검색은 데이터가 저장된 Block 값들의 저장 순서가 일정하지 않을 수있어 원하는 만큼의 빠른 검색 효과를 보장할 수없다는 특징을 가진다.
