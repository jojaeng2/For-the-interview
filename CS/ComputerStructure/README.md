# ComputerStructure

  - [1. 시스템버스란](#시스템-버스란)
  - [2. CPU의 구조와 기능](#2-cpu의-구조와-기능)
    - [CPU의 기본 구조](#cpu의-기본-구조)
    - [명령어 실행](#명령어-실행)
      - [인출 사이클](#인출-사이클)
      - [실행 사이클](#실행-사이클)
    - [인터럽트](#인터럽트)
    - [다중 인터럽트](#다중-인터럽트)
    - [간접 사이클](#간접-사이클)
    - [명령어 파이프라이닝](#명령어-파이프라이닝)
    - [멀티 코어](#멀티-코어)
    - [주소지정 방식](#주소지정-방식)
  - [3. 제어 유니트](#3-제어-유니트)
    - [제어 유니트의 기능](#제어-유니트의-기능)
    - [제어 유니트의 구조](#제어-유니트의-구조)
    - [제어 유니트의 동작](#제어-유니트의-동작)
  - [4. 기억장치](#4-기억장치)
    - [기억장치의 분류와 특성](#기억장치의-분류와-특성)
    - [계층적 기억장치시스템](#계층적-기억장치시스템)
    - [반도체 기억장치](#반도체-기억장치)
      - [RAM](#ram)
      - [DRAM VS SRAM](#dram-vs-sram)
      - [ROM](#rom)
      - [캐시 메모리](#캐시-메모리)

</br>

## 1. 시스템버스란
시스템 버스는 CPU와 다른 요소들 간의 정보교환 통로이다. 시스템 버스는 3가지 '하부 버스'로 구성된다.
<br>  
1. 주소 버스(address bus)  
CPU가 외부로 발생하는 주소 정보를 전송하는 신호 선들의 집합이다. 
2. 데이터 버스(data bus)  
CPU가 기억장치 혹은 I/O 장치와의 사이에 데이터를 전송하기 위한 신호 선들의 집합이다.
3. 제어 버스(control bus)  
시스템 내의 각종 요소들의 동작을 제어하는데 필요한 신호 선들의 집합이다. 

## 2. CPU의 구조와 기능
### CPU의 기본 구조
CPU는 기억장치에 저장되어 있는 프로그램 코드인 명령어들을 실행함으로써 프로그램 수행이라는 컴퓨터의 기본적인 기능을 수행하는데, 이를위해 CPU가 수행하는 세부적인 동작들을 순서대로 나열하면 아래와 같다.

1. 명령어 인출 : 기억장치로부터 명령어를 읽어온다.
2. 명령어 해독 : 수행해야 할 동작을 결정하기 위하여 명령어를 해독한다.
3. 데이터 인출 : 데이터가 필요한 경우에는 기억장치 혹은 I/O 장치로부터 데이터를 읽어온다.
4. 데이터 처리 : 데이터에 대한 산술적 혹은 논리적 연산을 수행한다.
5. 데이터 저장 : 명령어를 수행한 결과를 저장한다.

이러한 동작들을 수행하기 위해 CPU는 아래와 같은 내부 구성 요소들로 이루어져 있다.  

1. ALU  
각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈이다.  

2. 레지스터 세트  
CPU 내부에 위치한 기억장치로서, 액세스 속도가 컴퓨터의 기억장치들 중에서 가장 빠르다. 

3. 제어 유니트  
명령어를 해석하고, 그것을 실행하기 위한 제어 신호들을 순차적으로 발생시키는 하드웨어 모듈이다.  
명령어 실행에 필요한 각종 정보들의 전송 통로와 방향을 지정해주고, CPU 내부 요소들과 시스템 구성 요소들의 동작 시간도 결정해준다.

4. CPU 내부 버스  
ALU와 레지스터들 간의 데이터 이동을 위한 데이터 선들과 주소 선들, 그리고 제어 유니트로부터 발생되는 제어 신호들을 전송하는 선들로 구성된다. 

### 명령어 실행
CPU가 한 개의 명령어를 실행하는 데 필요한 전체 과정을 '명령어 사이클'이라고 부른다. 그리고 명령어 사이클은 CPU가 기억장치로부터 명령어를 읽어 오는 '명령어 인출' 단계와 인출된 명령어를 실행하는 '명령어 실행' 단계로 이루어진다.  

명령어를 실행하기 위하여 기본적으로 필요한 CPU 레지스터들은 아래와 같다.  
1. 프로그램 카운터 (PC)  
다음에 인출될 명령어의 주소를 가지고 있는 레지스터이다. 각 명령어가 인출된 후에는 그 내용이 자동적으로 1이 증가된다. 
2. 누산기 (AC)  
데이터를 일시적으로 저장하는 레지스터이다. 이 레지스터의 비트 수는 CPU가 한번에 연산 처리할 수있는 데이터 비트 수와 같다.
3. 명령어 레지스터 (IR)  
가장 최근에 인출된 명령어가 저장되어 있는 레지스터이다.
4. 기억장치 주소 레지스터 (MAR)   
프로그램 카운터에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터이다. 
5. 기억장치 버퍼 레지스터 (MBR)  
기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터이다.

#### 인출 사이클
기억장치의 지정된 위치로부터 명령어를 읽어오는 과정을 인출 사이클이라고 부른다.  
CPU는 각 명령어 사이클의 시작 단계에서 프로그램 카운터(PC)가 가리키는 기억장치의 위치로부터 명령어를 인출해 온다. 그런 다음 CPU는 PC의 내용을 1씩 증가시킴으로써 명령어들을 기억장치에 저장되어 있는 순서대로 읽어올 수 있도록 해준다. 

#### 실행 사이클
실행 사이클은 CPU가 인출된 명령어 코드를 '해독(decode)'하고, 그 결과에 따라 필요한 연산을 수행하는 것을 말한다. 

<br>

### 인터럽트
CPU로 하여금 현재 진행 중인 프로그램 처리를 중단하고 다른 프로그램을 처리하도록 요구하는 매커니즘을 인터럽트라고 부른다.
<br>
<br>
인터럽트는 CPU와 외부 장치들 간의 상호작용을 위해 필요한 기능이다.  
하지만, 이는 main 프로그램의 관점에서 단순히 정상적인 프로그램 처리의 흐름을 방해하는 동작이다. 그럼에도 인터럽트는 긴급한 상황에 대처하거나 외부 장치들과의 상호 작용을 위하여 반드시 필요한 기능이다. 

CPU가 어떤 프로그램을 순차적으로 수행하는 도중에 외부로부터 인터럽트 요구가 들어오게 되면, CPU는 원래의 프로그램 수행을 중단하고, 요구된 인터럽트를 처리해주기 위한 프로그램을 먼저 수행한다.  
그리고 인터럽트에 대한 처리가 끝나면, CPU는 원래의 프로그램으로 복귀(return)하여 수행을 계속한다.

<br>
CPU는 인터럽트 요구가 들어오면 그것을 인식할 수있어야 하며, 어떤 장치가 인터럽트를 요구하였는지 확인하여 해당 인터럽트 서비스 루틴을 수행하고, 중단했던 원래 프로그램의 수행을 계속할 수있어야 한다.   
<br>
이를위해 CPU는 각 명령어의 실행 사이클을 종료하고 다음 명령어를 위한 인출 사이클을 시작하기 전에, 인터럽트 요구 신호가 들어와서 대기중인지 검사해야 한다. 만약 인터럽트 요구가 들어온 상태라면, CPU는 아래와 같은 동작들을 수행한다.  

<br>
<br>

1. 현재의 PC 내용을 '스택'에 저장한다. 이것은 인터럽트 처리를 완료한 후에 복귀할 주소를 저장해두기 위한 절차이다.  
2. 인터럽트 서비스 루틴을 호출하기 위하여 그 루틴의 시작 주소를 PC에 적재한다. 이때 시작 주소는 인터럽트를 요구한 장치로부터 전송된다. 


### 다중 인터럽트
어떤 외부 장치를 위한 인터럽트 서비스 루틴의 명령어들이 실행되고 있는 동안에 다른 외부 장치가 인터럽트 요구를 발생할 수도 있는데, 이것이 '다중 인터럽트'이다.  
다중 인터럽트를 처리하는 방법으로는 두 가지가 있다.  

1. CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에 새로운 인터럽트 요구가 들어오더라도 인터럽트 사이클을 수행하지 않도록 하는 방법
2. 인터럽트에 우선순위를 지정하는 방법

### 간접 사이클
어떤 연산을 수행하는 경우 데이터가 기억장치에 저장되어 있다면, 명령어에는 그 데이터를 읽어오기 위한 기억장치 주소가 포함되어 있을 것이다. 그런데 어떤 명령어의 경우 포함하고 있는 주소가 데이터의 주소가 아니라, 데이터가 저장된 '기억장소의 주소'를 가리킨다.  
<br>
연산에서 사용될 데이터의 주소가 기억장치의 어떤 위치에 저장되어 있고, 명령어에 포함되어 있는 주소는 그 위치를 가리키는 것이다.
<br>
이 경우에는 실행 사이클이 시작되기 전에, 그 데이터의 실제 주소를 기억장치로부터 읽어오는 과정이 먼저 수행되어야 한다.

### 명령어 파이프라이닝
CPU의 성능은 컴퓨터시스템의 프로그램 처리 시간에 직접 영향을 주기 때문에, 그 속도를 향상시키기 위하여 여러 방법들이 사용되고 있다.  
여러 기법 중 가장 간단하면서도 분명한 효과를 얻을 수 있는 방법이 '명령어 파이프라이닝'이다. 
<br>
<br>
이것은 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 '독립적인 단계'로 분할하고, 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 높여주는 기술을 말한다. 
<br>
예를들어, CPU는 명령어를 실행하기 위해 '인출 사이클'과 '실행 사이클'을 거친다. 만약 각각의 사이클을 처리하는 하드웨어를 독립적인 모듈로 구성할 수있다면, 동시에 A라는 명령어의 '인출 사이클'과 B라는 명령어의 '실행 사이클'을 수행할 수있다. 그러면 여러개의 명령어를 수행하는 CPU의 총 처리 시간이 줄어들고, CPU 성능이 향상된다. 

### 멀티 코어
CPU 코어는 CPU 칩에 포함되던 하드웨어 중에서 명령어 실행에 반드시 필요한 핵심 모듈들을 말하는데, ALU, 레지스터 세트 등을 말한다.  
<br>
이러한 CPU 코어 여러 개를 하나의 칩에 넣은 것을 '멀티-코어 프로세서'라고 부른다.  
각 CPU 코어는 별도의 하드웨어 모듈로 구현된 상태로 하나의 칩에 포함되며, 내부 캐시와 시스템 버스 인터페이스만 공유한다. 따라서 각 CPU 코어는 프로그램 실행을 독립적으로 수행하며, 필요한 경우에만 공유 캐시를 통해 정보를 교환한다.
<br>

### 주소지정 방식
명령어의 길이가 늘어나면, 필드의 비트 수가 증가하지만, 일반적으로 명령어 비트의 수는 CPU가 처리하는 단어의 길이와 같도록 제한된다.  
그리고 이렇게 제한된 수의 명령어 비트들을 이용하여 사용자로 하여금 더 큰 용량의 기억장치를 사용할 수있도록 해주는 여러가지 '주소지정 방식'들이 존재한다. 

1. 직접 주소지정 방식  
직접 주소지정 방식은 명령어 내 오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 가장 간단한 방식이다.  
이 방식을 이용하면 데이터 인출을 위하여 한 번의 기억장치 액세스만 필요하며, 유효 주소 결정을 위한 다른 절차나 계산이 필요하지 않다.  
그런데, 명령어에서 일정 부분은 연산 코드를 위해 사용되기 때문에 남은 비트들만 주소 비트로 사용될 수 있다. 만약 명령어의 길이가 n비트이고, 그 중에서 연산 코드의 비트들이 p개라면, 직접 주소시정 방식을 이용하여 지정할 수있는 기억장소의 수는 최대 2^n-p개가 된다.  
이와같이 직접 액세스할 수있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제한되는 것이 이 방식의 단점이다.

2. 간접 주소지정 방식  
명령어의 오퍼랜드 필드의 기억장치 주소가 가리키는 위치에 실제 사용할 데이터의 유효 주소를 저장해두는 방법이다.  
이 방법은 직접 주소지정 방식의 문제인 '짧은 주소 필드의 길이'를 해결할 수있다.   
최대 기억장치 용량이 기억장치 주소가 가리키는 위치의 전체 비트 수에 의해 결정되기 때문이다.  
기억장치의 단어 길이가 n비트라면, 이 명령어에 의해 직접 주소지정 될 수있는 기억 장소들의 수는 최대 2^n개가 될 수있다.  
간접 주소지정 방식의 단점은 실행 사이클 동안에 두 번의 기억장치 액세스가 필요하다는 점이다.  
첫 번째 액세스는 주소를 읽어오기 위한 것이고, 두 번째는 그 주소가 지정하는 위치로부터 실제 데이터를 인출하기 위해 액세스가 필요하다.

3. 즉시 주소지정 방식  
즉시 주소지정 방식을 사용하는 명령어는 연산에서 사용할 데이터를 명령어 코드 내에 포함하고 있다. 즉, 오퍼랜드 필드의 내용이 연산에 즉시 사용될 수 있는 실제 데이터이다. 
따라서 데이터 인출 과정이 별도로 필요하지 않고, 이 방식은 프로그램에서 레지스터나 변수의 초기 값을 어떤 상수값으로 세트하는데 주로 사용된다.  
이 방식의 장점은 데이터를 인출하기 위하여 기억장치를 액세스할 필요가 없기 때문에 실행 사이클이 짧아진다는 점이다. 단점으로는 사용할 수있는 수의 크기가 오퍼랜드 필드의 비트 수에 의해 제한된다는 점이 있다.

4. 레지스터 주소지정 방식  
레지스터 주소지정 방식에서는 연산에 사용될 데이터가 레지스터에 저장되어 있다. 따라서 오퍼랜드 필드의 내용은 레지스터 번호로 사용되며, 그 번호가 가리키는 레지스터의 내용이 명령어 실행 과정에서 데이터로 사용된다. 
이 방식의 장점은 명령어 형식에서 오퍼랜드 필드의 비트 수가 적어도 되고, 데이터 인출을 위해 기억장치를 액세스할 필요가 없다는 점이다. 또한 CPU 내부 레지스터에 대한 액세스 시간이 주기억장치 액세스 시간 보다 훨씬 더 짧기 때문에 명령어 실행 시간도 짧아진다.  
그러나 이 방식을 사용하면 데이터가 저장될 수있는 위치가 CPU 내부 레지스터로 제한된다는 단점이 있다.


## 3. 제어 유니트
### 제어 유니트의 기능
CPU가 실행하는 명령어들을 인출하여 해독하고 실행하는 과정이 순차적으로 발생되도록 하기 위해서는 그 순간마다 적절한 제어 신호들이 생성되어 해당 하드웨어 모듈로 보내져야 한다.  
<br>
이러한 역할을 담당하는 것이 '제어 유니트(control unit)'이다. 

제어 유니트가 수행하는 주요 기능은 아래와 같다.  
1. 명령어 코드의 해독
2. 명령어 실행에 필요한 제어 신호들의 발생

제어 유니트는 컴퓨터 프로그램을 구성하고 있는 명령어들을 '해독(decode)'하고, 그 결과에 따라 명령어 실행에 필요한 동작들을 수행시키기 위한 '제어 신호'들을 발생시키는 장치이다. 

이것을 다른말로 표현하면 명령어 사이클이 적절히 수행되도록 모든 동작들을 제어하는 장치인 것이다.

### 제어 유니트의 구조
<br>

![image](https://user-images.githubusercontent.com/76645095/178960330-90192b8d-ee8c-43f7-b85e-a76bf07b841e.png)

<br>
위의 그림은 제어 유니트의 내부 구조를 간략하게 보여주고 있는데, 주요 구성 요소들과 각 기능을 보면 아래와 같다.

1. 명령어 해독기  
명령어 레지스터(IR)로부터 들어오는 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작 주소를 결정한다.
2. 제어 주소 레지스터(CAR)  
다음에 실행할 마이크로명령어의 주소를 저장하는 레지스터이다. 이 주소는 제어 기억장치의 특정 위치를 가리킨다.
3. 제어 기억장치  
마이크로명령어들로 이루어진 마이크로프로그램을 저장하는 내부 기억장치이다.
4. 제어 버퍼 레지스터(CBR)  
제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터이다. 
5. 서브루틴 레지스터(SBR)  
서브루틴이 호출되는 경우에, 현재의 CAR 내용을 일시적으로 저장하는 레지스터이다.
6. 순서제어 모듈  
마이크로명령어의 실행 순서를 결정하는 회로들의 집합이다. 

### 제어 유니트의 동작
인출 사이클 동안 명령어 레지스터로 적재된 명령어 비트들 중에서 '연산 코드(op-code)' 부분은 제어 유니트의 '명령어 해독기'로 들어온다.  
이 연산 코드가 지정하는 연산은 실행 사이클 동안에 '제어 기억장치'에 저장된 해당 루틴을 실행함으로써 수행된다.  
따라서 명령어 해독기는 연산 코드를 이용하여 제어 기억장치 내 해당 실행 사이클 루틴의 주소를 찾아야 한다.   
<br>
실행 사이클 루틴을 찾는 방법에는 여러 방법이 존재하지만, '사상(mapping)' 방식이 가장 대표적이다.  
<br>
<br>

## 4. 기억장치
### 기억장치의 분류와 특성
모든 컴퓨터 시스템들은 프로그램과 데이터를 저장하기 위한 장치로서 '주기억장치'와 '보조저장장치'를 가지고 있다.  
그러나 최근 CPU와 기억장치들 간의 속도 차이가 커지고 필요한 저장 용량이 증가함에 따라, 시스템 성능을 향상시키고 가격대성능비를 개선하기 위하여 다양한 유형의 기억장치들을 시스템에 포함시키고 있다.  
<br>
기억장치는 CPU가 직접 액세스할 수있는 '내부 기억장치'와 '장치 제어기'를 통하여 액세스할 수있는 '외부 기억장치'로 구성된다.  
<br>

기억장치 시스템을 설계하는 데 있어 고려해야 할 주요 특성은 '용량'과 '액세스 속도'이다. 이때 '액세스'는 CPU가 어떤 정보를 기억장치에 쓰거나 기억장치로부터 읽는 동작을 말한다.  

기억장치 시스템의 주요 특성인 '액세스 속도'와 관련된 파라미터로는 다음과 같은 것들이 존재한다.  

1. 액세스 시간  
주소와 읽기/쓰기 신호가 기억장치에 도착하는 순간부터 데이터가 저장되거나 읽혀지는 동작이 완료되는 순간까지의 시간을 말한다.
2. 기억장치 사이클 시간  
액세스 시간과 데이터 복원 시간을 합한 시간을 말하는데, 데이터 복원 시간은 사실 잘 와닿지 않는게 정상이다.
<br>
데이터 복원을 하는 이유는 읽기 동작 후 정보가 소멸하는 저장장치들이 존재했기 때문인데, 최근의 저장장치들은 내용이 지워지지 않기 때문에 기억장치 액세스 시간과 사이클 시간이 같다. 
3. 데이터 전송률  
데이터 전송률은 기억장치로부터 초당 읽혀지거나 쓰여질 수있는 비트 수를 말한다.  

기억장치는 저장하는 성질에 따라 두 가지 유형으로 나눌 수도 있다.  
1. 휘발성 기억장치  
저장된 정보가 시간이 지남에 따라 점차 사라지거나, 전력 공급이 중단되면 소멸되는 기억장치를 말한다.
2. 비휘발성 기억장치  
저장된 정보는 필요에 의해 변경될 때까지는 그대로 유지되며, 정보 유지를 위하여 지속적으로 전력을 공급할 필요가 없는 기억장치이다. 

### 계층적 기억장치시스템
#### 계층적 기억장치시스템이란?
컴퓨터시스템의 성능에 가장 중요한 영향을 미치는 요소는 CPU이다.  
그러나 CPU가 아무리 빠르더라도 기억장치가 느리다면, CPU는 명령어나 데이터를 액세스하는 과정에서 많은 시간을 기다리게 되어 시스템 성능이 저하될 수밖에 없다.  
<br>
기억장치들은 유형에 따라 기능, 속도, 용량, 가격이 매우 다양하다. 그런데 컴퓨터시스템에서 기억장치는 속도뿐 아니라 다른 측면도 함께 고려해 구성해야 한다.  
따라서 대부분의 컴퓨터시스템은 여러 유형의 기억장치들을 계층적으로 구성하여 설치함으로써, 평균 기억장치 액세스 속도를 높여 가격대성능비도 적절히 유지되도록 하고, 이러한 기법을 계층적 기억장치시스템이라 부른다.

<br>

#### 필요성 및 효과
컴퓨터 설계의 목표가 성능을 높이는 것이라면, 가격이 비싸고 용량은 적더라도 액세스 속도가 높은 기억장치를 사용해야 할 것이다.   
그러나 만약 용량도 증가시키고 동시에 비용도 낮추기를 원한다면, 액세스 속도가 낮은 기억장치도 사용할 수밖에 없을 것이다.  
<br>
이러한 어려움을 해결할 수있는 방법은 어떤 한 가지 기억장치나 제조 기술에 의존하는 것이 아니라, 여러 종류의 기억장치들을 이용하여 계층적 기억장치 시스템을 구성하는 것이다.  

기억장치를 적절히 계층적 구조로 설계한다면 속도와 용량 및 가격 면에서 더 개선된 기억장치시스템을 구축할 수있다.  

### 반도체 기억장치
#### RAM
RAM(Random Access Memory)는 임의 액세스 방식을 이용하는 반도체 기억장치이다.  
이 기억장치에 저장된 각 단어들은 CPU가 전송하는 주소에 의해 지정되어 '직접 액세스'된다.  
따라서 칩 내의 어느 위치에 있든, 액세스에 걸리는 시간이 동일하다. RAM의 특징은 데이터를 읽는 것과 쓰는 것이 모두 가능하며, 이 동작들이 전기적인 신호들을 이용하여 이루어진다는 것이다.  

#### DRAM VS SRAM
RAM은 제조 기술에 따라 DRAM과 SRAM으로 분류된다.  
DRAM(Dynamic RAM)은 전하를 충전하는 방식으로 비트값을 저장하는 기억셀들로 이뤄져 있다. 즉, 전하 존재 여부에 따라 2진수 1과 0이 구분된다.  
<br>
그런데, DRAM은 점차적으로 '방전'되는 성질이 있기 때문에, 저장 상태를 유지하기 위하여 주기적으로 '재충전' 해줘야 한다.  
<br>
SRAM(Static RAM)에서는 데이터가 안정된 상태로 저장될 수있으므로, 전력이 공급되는 동안에는 재충전 없이도 데이터를 계속 유지할 수있다.  

<br>
DRAM과 SRAM은 모두 휘발성이다.   

DRAM의 각 기억셀은 SRAM의 경우보다 더 간단하고, 더 작다. 결과적으로 DRAM의 밀도가 더 높으며, 같은 용량의 SRAM보다 비트당 가격이 더 저렴하다.  
<br>
SRAM은 DRAM 보다 속도가 더 빠르다는 장점이 있다. 이러한 특징들 때문에 DRAM은 주로 주기억장치로 사용되며, SRAM은 높은 속도가 필요한 캐시로 사용된다.  

#### ROM
ROM(Read Only Memory)은 RAM과 대조를 이루는 반도체 기억장치이다.  
명칭이 의미하듯이 ROM은 내용을 읽는 것만 가능하고, 쓰는 것은 불가능하다. 따라서 ROM은 프로그램이나 변경될 수없는 데이터를 저장하는 데 사용된다.  

ROM에는 주로 아래와 같은 내용들이 저장된다.

1. 시스템 초기화 및 진단 프로그램
2. 빈번히 사용되는 함수들과 서브루틴들
3. 제어 유니트의 마이크로프로그램


ROM은 전원 공급이 중단되어도 내용을 잃어버리지 않고 영구 저장할 수있는 반도체 기억장치이다.  
ROM을 사용함으로써 얻을 수있는 장점은 프로그램이나 데이터가 영구 저장되므로 보조저장장치로부터 매번 이동시킬 필요가 없기 때문에 액세스 시간이 짧아진다는 점이다.  
<br>
그러나 쓰기 동작이 불가능하기 때문에, 변경할 필요가 없는 프로그램 코드나 데이터를 저장하는 데만 사용된다. 

<br>

#### 캐시 메모리
주기억장치로 사용되는 반도체 기억장치 부품들의 액세스 속도는 크게 개선되었지만, 여전히 CPU 속도보다 느리다.  
따라서 CPU는 프로그램 코드나 데이터를 인출하는 과정에서 상당히 긴 시간을 기다려야 한다.  
<br>
CPU와 주기억장치의 속도 차이로 인한 성능 저하를 방지하기 위한 방법으로서, 대부분의 컴퓨터시스템에서는 아래의 그림과 같이 CPU와 주기억장치 사이에 고속의 기억장치 칩들을 사용한 소용량의 '캐시 메모리(cache memory)'를 설치하고 있다.  

<img width="699" alt="image" src="https://user-images.githubusercontent.com/76645095/179648126-edc073c9-90a9-47ab-8bd9-c56f3df18543.png">

<br>

캐시는 CPU 칩과 인접한 곳에 설치하며, CPU 칩 내부에 포함되기도 한다.   
캐시로는 고속의 반도체 기억장치 칩들을 사용하기 때문에, 캐시 액세스 시간이 주기억장치 액세스 시간보다 상당히 더 짧다.  
그러나, 칩의 가격이 그만큼 더 높아지고 설치할 수있는 공간도 제한되기 때문에 캐시의 용량은 일반적으로 주기억장치의 용량에 비해 훨씬 더 적다.
<br>

CPU는 기억장치로부터 어떤 데이터를 읽으려고 할 때 먼저 그 데이터가 캐시에 있는지 확인한다.  
만약 있다면, 데이터를 즉시 CPU로 인출할 수있기 때문에 액세스 시간이 크게 단축되며, 만약 없다면 데이터를 주기억장치로부터 인출해야 하기 때문에 더 오랜 시간이 걸린다.  
<br>
CPU가 원하는 데이터가 이미 캐시에 적재되어 있는 상태를 '캐시 적중(cache hit)'이라고 하며 CPU가 원하는 데이터가 캐시에 없는 상태를 '캐시 미스(cache miss)'라고 부른다.  

캐시 적중률이 높아질수록 평균 액세스 시간은 캐시의 액세스 시간에 근접하게 되지만, 캐시 적중률은 프로그램과 데이터의 '지역성(locality)'에 크게 의존한다.  
지역성이란 CPU가 주기억장치의 특정 부분(지역)에 위치한 프로그램 코드나 데이터를 빈번히 혹은 집중적으로 액세스하는 현상을 말한다.  
<br>
프로그램은 실제로 이러한 지역성들 때문에 캐시에 적재되어 있는 정보들이 그 후에 CPU에 의해 다시 사용되는 경우가 많다.  
그러나, 지역성은 프로그램의 특성에 따라 달라지기 때문에 한계가 있다.  
<br>

캐시에 데이터가 존재하지 않아 주기억장치에 액세스할 때 함께 인출되는 정보들의 그룹을 '블록(block)'이라고 부른다.  
블록이 커지면 더 많은 정보들을 한 번에 읽어올 수있지만, 인출 시간이 그만큼 더 길어지며, 아래의 그림은 블록으로 나누어진 주기억장치와 그에 따른 캐시의 조직을 보여준다.  

<img width="1576" alt="image" src="https://user-images.githubusercontent.com/76645095/179650747-5ff58079-17f7-4073-8d43-b57fef7929ac.png">

<br>

주기억장치는 2^n개의 단어들로 구성되며, 각 단어는 n 비트의 주소에 의해 지정된다.  
선인출을 위하여 주기억장치를 K개의 단어들로 이루어진 블록으로 나눌 경우에 전체 블록들의 수는 2^n/K가 된다.
<br>

캐시는 m개의 라인들로 구성되는데, 각 라인은 주기억장치 블록의 크기와 같아야 한다.  
선인출 방식을 적용하는 경우 CPU가 주기억장치로부터 어떤 단어를 읽으면, 그 단어를 포함하고 있는 블록 전체가 캐시 라인들 중 어느 하나에 적재된다.
<br>

캐시의 용량은 작기 때문에 캐시 라인의 수는 주기억장치 블록의 수보다 훨씬 더 적다. 따라서 어느 순간에든 기억장치 블록들 중의 일부만이 캐시에 적재될 수있고 캐시의 각 라인은 여러 개의 블록들에 의해 공유된다.
<br>

따라서 각 캐시 라인에는 데이터 블록 외에도 현재 자신이 공유하는 블록들 중의 어느것이 적재되어 있는지를 구분해주는 '태그(tag)'가 저장되어 있어야 한다.

