# ComputerStructure

  - [1. 시스템버스란](#시스템-버스란)
  - [2. CPU의 구조와 기능](#2-cpu의-구조와-기능)
    - [CPU의 기본 구조](#cpu의-기본-구조)
    - [명령어 실행](#명령어-실행)
      - [인출 사이클](#인출-사이클)
      - [실행 사이클](#실행-사이클)
    - [인터럽트](#인터럽트)
    - [다중 인터럽트](#다중-인터럽트)
    - [간접 사이클](#간접-사이클)
    - [명령어 파이프라이닝](#명령어-파이프라이닝)
    - [멀티 코어](#멀티-코어)
    - [주소지정 방식](#주소지정-방식)
  - [3. 제어 유니트](#3-제어-유니트)
    - [제어 유니트의 기능](#제어-유니트의-기능)
    - [제어 유니트의 구조](#제어-유니트의-구조)
    - [제어 유니트의 동작](#제어-유니트의-동작)
  - [4. 기억장치](#4-기억장치)

</br>

## 1. 시스템버스란
시스템 버스는 CPU와 다른 요소들 간의 정보교환 통로이다. 시스템 버스는 3가지 '하부 버스'로 구성된다.
<br>  
1. 주소 버스(address bus)  
CPU가 외부로 발생하는 주소 정보를 전송하는 신호 선들의 집합이다. 
2. 데이터 버스(data bus)  
CPU가 기억장치 혹은 I/O 장치와의 사이에 데이터를 전송하기 위한 신호 선들의 집합이다.
3. 제어 버스(control bus)  
시스템 내의 각종 요소들의 동작을 제어하는데 필요한 신호 선들의 집합이다. 

## 2. CPU의 구조와 기능
### CPU의 기본 구조
CPU는 기억장치에 저장되어 있는 프로그램 코드인 명령어들을 실행함으로써 프로그램 수행이라는 컴퓨터의 기본적인 기능을 수행하는데, 이를위해 CPU가 수행하는 세부적인 동작들을 순서대로 나열하면 아래와 같다.

1. 명령어 인출 : 기억장치로부터 명령어를 읽어온다.
2. 명령어 해독 : 수행해야 할 동작을 결정하기 위하여 명령어를 해독한다.
3. 데이터 인출 : 데이터가 필요한 경우에는 기억장치 혹은 I/O 장치로부터 데이터를 읽어온다.
4. 데이터 처리 : 데이터에 대한 산술적 혹은 논리적 연산을 수행한다.
5. 데이터 저장 : 명령어를 수행한 결과를 저장한다.

이러한 동작들을 수행하기 위해 CPU는 아래와 같은 내부 구성 요소들로 이루어져 있다.  

1. ALU  
각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈이다.  

2. 레지스터 세트  
CPU 내부에 위치한 기억장치로서, 액세스 속도가 컴퓨터의 기억장치들 중에서 가장 빠르다. 

3. 제어 유니트  
명령어를 해석하고, 그것을 실행하기 위한 제어 신호들을 순차적으로 발생시키는 하드웨어 모듈이다.  
명령어 실행에 필요한 각종 정보들의 전송 통로와 방향을 지정해주고, CPU 내부 요소들과 시스템 구성 요소들의 동작 시간도 결정해준다.

4. CPU 내부 버스  
ALU와 레지스터들 간의 데이터 이동을 위한 데이터 선들과 주소 선들, 그리고 제어 유니트로부터 발생되는 제어 신호들을 전송하는 선들로 구성된다. 

### 명령어 실행
CPU가 한 개의 명령어를 실행하는 데 필요한 전체 과정을 '명령어 사이클'이라고 부른다. 그리고 명령어 사이클은 CPU가 기억장치로부터 명령어를 읽어 오는 '명령어 인출' 단계와 인출된 명령어를 실행하는 '명령어 실행' 단계로 이루어진다.  

명령어를 실행하기 위하여 기본적으로 필요한 CPU 레지스터들은 아래와 같다.  
1. 프로그램 카운터 (PC)  
다음에 인출될 명령어의 주소를 가지고 있는 레지스터이다. 각 명령어가 인출된 후에는 그 내용이 자동적으로 1이 증가된다. 
2. 누산기 (AC)  
데이터를 일시적으로 저장하는 레지스터이다. 이 레지스터의 비트 수는 CPU가 한번에 연산 처리할 수있는 데이터 비트 수와 같다.
3. 명령어 레지스터 (IR)  
가장 최근에 인출된 명령어가 저장되어 있는 레지스터이다.
4. 기억장치 주소 레지스터 (MAR)   
프로그램 카운터에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터이다. 
5. 기억장치 버퍼 레지스터 (MBR)  
기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터이다.

#### 인출 사이클
기억장치의 지정된 위치로부터 명령어를 읽어오는 과정을 인출 사이클이라고 부른다.  
CPU는 각 명령어 사이클의 시작 단계에서 프로그램 카운터(PC)가 가리키는 기억장치의 위치로부터 명령어를 인출해 온다. 그런 다음 CPU는 PC의 내용을 1씩 증가시킴으로써 명령어들을 기억장치에 저장되어 있는 순서대로 읽어올 수 있도록 해준다. 

#### 실행 사이클
실행 사이클은 CPU가 인출된 명령어 코드를 '해독(decode)'하고, 그 결과에 따라 필요한 연산을 수행하는 것을 말한다. 

<br>

### 인터럽트
CPU로 하여금 현재 진행 중인 프로그램 처리를 중단하고 다른 프로그램을 처리하도록 요구하는 매커니즘을 인터럽트라고 부른다.
<br>
<br>
인터럽트는 CPU와 외부 장치들 간의 상호작용을 위해 필요한 기능이다.  
하지만, 이는 main 프로그램의 관점에서 단순히 정상적인 프로그램 처리의 흐름을 방해하는 동작이다. 그럼에도 인터럽트는 긴급한 상황에 대처하거나 외부 장치들과의 상호 작용을 위하여 반드시 필요한 기능이다. 

CPU가 어떤 프로그램을 순차적으로 수행하는 도중에 외부로부터 인터럽트 요구가 들어오게 되면, CPU는 원래의 프로그램 수행을 중단하고, 요구된 인터럽트를 처리해주기 위한 프로그램을 먼저 수행한다.  
그리고 인터럽트에 대한 처리가 끝나면, CPU는 원래의 프로그램으로 복귀(return)하여 수행을 계속한다.

<br>
CPU는 인터럽트 요구가 들어오면 그것을 인식할 수있어야 하며, 어떤 장치가 인터럽트를 요구하였는지 확인하여 해당 인터럽트 서비스 루틴을 수행하고, 중단했던 원래 프로그램의 수행을 계속할 수있어야 한다.   
<br>
이를위해 CPU는 각 명령어의 실행 사이클을 종료하고 다음 명령어를 위한 인출 사이클을 시작하기 전에, 인터럽트 요구 신호가 들어와서 대기중인지 검사해야 한다. 만약 인터럽트 요구가 들어온 상태라면, CPU는 아래와 같은 동작들을 수행한다.  

<br>
<br>

1. 현재의 PC 내용을 '스택'에 저장한다. 이것은 인터럽트 처리를 완료한 후에 복귀할 주소를 저장해두기 위한 절차이다.  
2. 인터럽트 서비스 루틴을 호출하기 위하여 그 루틴의 시작 주소를 PC에 적재한다. 이때 시작 주소는 인터럽트를 요구한 장치로부터 전송된다. 


### 다중 인터럽트
어떤 외부 장치를 위한 인터럽트 서비스 루틴의 명령어들이 실행되고 있는 동안에 다른 외부 장치가 인터럽트 요구를 발생할 수도 있는데, 이것이 '다중 인터럽트'이다.  
다중 인터럽트를 처리하는 방법으로는 두 가지가 있다.  

1. CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에 새로운 인터럽트 요구가 들어오더라도 인터럽트 사이클을 수행하지 않도록 하는 방법
2. 인터럽트에 우선순위를 지정하는 방법

### 간접 사이클
어떤 연산을 수행하는 경우 데이터가 기억장치에 저장되어 있다면, 명령어에는 그 데이터를 읽어오기 위한 기억장치 주소가 포함되어 있을 것이다. 그런데 어떤 명령어의 경우 포함하고 있는 주소가 데이터의 주소가 아니라, 데이터가 저장된 '기억장소의 주소'를 가리킨다.  
<br>
연산에서 사용될 데이터의 주소가 기억장치의 어떤 위치에 저장되어 있고, 명령어에 포함되어 있는 주소는 그 위치를 가리키는 것이다.
<br>
이 경우에는 실행 사이클이 시작되기 전에, 그 데이터의 실제 주소를 기억장치로부터 읽어오는 과정이 먼저 수행되어야 한다.

### 명령어 파이프라이닝
CPU의 성능은 컴퓨터시스템의 프로그램 처리 시간에 직접 영향을 주기 때문에, 그 속도를 향상시키기 위하여 여러 방법들이 사용되고 있다.  
여러 기법 중 가장 간단하면서도 분명한 효과를 얻을 수 있는 방법이 '명령어 파이프라이닝'이다. 
<br>
<br>
이것은 명령어를 실행하는데 사용되는 하드웨어를 여러 개의 '독립적인 단계'로 분할하고, 동시에 서로 다른 명령어들을 처리하도록 함으로써 CPU의 성능을 높여주는 기술을 말한다. 
<br>
예를들어, CPU는 명령어를 실행하기 위해 '인출 사이클'과 '실행 사이클'을 거친다. 만약 각각의 사이클을 처리하는 하드웨어를 독립적인 모듈로 구성할 수있다면, 동시에 A라는 명령어의 '인출 사이클'과 B라는 명령어의 '실행 사이클'을 수행할 수있다. 그러면 여러개의 명령어를 수행하는 CPU의 총 처리 시간이 줄어들고, CPU 성능이 향상된다. 

### 멀티 코어
CPU 코어는 CPU 칩에 포함되던 하드웨어 중에서 명령어 실행에 반드시 필요한 핵심 모듈들을 말하는데, ALU, 레지스터 세트 등을 말한다.  
<br>
이러한 CPU 코어 여러 개를 하나의 칩에 넣은 것을 '멀티-코어 프로세서'라고 부른다.  
각 CPU 코어는 별도의 하드웨어 모듈로 구현된 상태로 하나의 칩에 포함되며, 내부 캐시와 시스템 버스 인터페이스만 공유한다. 따라서 각 CPU 코어는 프로그램 실행을 독립적으로 수행하며, 필요한 경우에만 공유 캐시를 통해 정보를 교환한다.
<br>

### 주소지정 방식
명령어의 길이가 늘어나면, 필드의 비트 수가 증가하지만, 일반적으로 명령어 비트의 수는 CPU가 처리하는 단어의 길이와 같도록 제한된다.  
그리고 이렇게 제한된 수의 명령어 비트들을 이용하여 사용자로 하여금 더 큰 용량의 기억장치를 사용할 수있도록 해주는 여러가지 '주소지정 방식'들이 존재한다. 

1. 직접 주소지정 방식  
직접 주소지정 방식은 명령어 내 오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 가장 간단한 방식이다.  
이 방식을 이용하면 데이터 인출을 위하여 한 번의 기억장치 액세스만 필요하며, 유효 주소 결정을 위한 다른 절차나 계산이 필요하지 않다.  
그런데, 명령어에서 일정 부분은 연산 코드를 위해 사용되기 때문에 남은 비트들만 주소 비트로 사용될 수 있다. 만약 명령어의 길이가 n비트이고, 그 중에서 연산 코드의 비트들이 p개라면, 직접 주소시정 방식을 이용하여 지정할 수있는 기억장소의 수는 최대 2^n-p개가 된다.  
이와같이 직접 액세스할 수있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제한되는 것이 이 방식의 단점이다.

2. 간접 주소지정 방식  
명령어의 오퍼랜드 필드의 기억장치 주소가 가리키는 위치에 실제 사용할 데이터의 유효 주소를 저장해두는 방법이다.  
이 방법은 직접 주소지정 방식의 문제인 '짧은 주소 필드의 길이'를 해결할 수있다.   
최대 기억장치 용량이 기억장치 주소가 가리키는 위치의 전체 비트 수에 의해 결정되기 때문이다.  
기억장치의 단어 길이가 n비트라면, 이 명령어에 의해 직접 주소지정 될 수있는 기억 장소들의 수는 최대 2^n개가 될 수있다.  
간접 주소지정 방식의 단점은 실행 사이클 동안에 두 번의 기억장치 액세스가 필요하다는 점이다.  
첫 번째 액세스는 주소를 읽어오기 위한 것이고, 두 번째는 그 주소가 지정하는 위치로부터 실제 데이터를 인출하기 위해 액세스가 필요하다.

3. 즉시 주소지정 방식  
즉시 주소지정 방식을 사용하는 명령어는 연산에서 사용할 데이터를 명령어 코드 내에 포함하고 있다. 즉, 오퍼랜드 필드의 내용이 연산에 즉시 사용될 수 있는 실제 데이터이다. 
따라서 데이터 인출 과정이 별도로 필요하지 않고, 이 방식은 프로그램에서 레지스터나 변수의 초기 값을 어떤 상수값으로 세트하는데 주로 사용된다.  
이 방식의 장점은 데이터를 인출하기 위하여 기억장치를 액세스할 필요가 없기 때문에 실행 사이클이 짧아진다는 점이다. 단점으로는 사용할 수있는 수의 크기가 오퍼랜드 필드의 비트 수에 의해 제한된다는 점이 있다.

4. 레지스터 주소지정 방식  
레지스터 주소지정 방식에서는 연산에 사용될 데이터가 레지스터에 저장되어 있다. 따라서 오퍼랜드 필드의 내용은 레지스터 번호로 사용되며, 그 번호가 가리키는 레지스터의 내용이 명령어 실행 과정에서 데이터로 사용된다. 
이 방식의 장점은 명령어 형식에서 오퍼랜드 필드의 비트 수가 적어도 되고, 데이터 인출을 위해 기억장치를 액세스할 필요가 없다는 점이다. 또한 CPU 내부 레지스터에 대한 액세스 시간이 주기억장치 액세스 시간 보다 훨씬 더 짧기 때문에 명령어 실행 시간도 짧아진다.  
그러나 이 방식을 사용하면 데이터가 저장될 수있는 위치가 CPU 내부 레지스터로 제한된다는 단점이 있다.


## 3. 제어 유니트
### 제어 유니트의 기능
CPU가 실행하는 명령어들을 인출하여 해독하고 실행하는 과정이 순차적으로 발생되도록 하기 위해서는 그 순간마다 적절한 제어 신호들이 생성되어 해당 하드웨어 모듈로 보내져야 한다.  
<br>
이러한 역할을 담당하는 것이 '제어 유니트(control unit)'이다. 

제어 유니트가 수행하는 주요 기능은 아래와 같다.  
1. 명령어 코드의 해독
2. 명령어 실행에 필요한 제어 신호들의 발생

제어 유니트는 컴퓨터 프로그램을 구성하고 있는 명령어들을 '해독(decode)'하고, 그 결과에 따라 명령어 실행에 필요한 동작들을 수행시키기 위한 '제어 신호'들을 발생시키는 장치이다. 

이것을 다른말로 표현하면 명령어 사이클이 적절히 수행되도록 모든 동작들을 제어하는 장치인 것이다.

### 제어 유니트의 구조
<br>

![image](https://user-images.githubusercontent.com/76645095/178960330-90192b8d-ee8c-43f7-b85e-a76bf07b841e.png)

<br>
위의 그림은 제어 유니트의 내부 구조를 간략하게 보여주고 있는데, 주요 구성 요소들과 각 기능을 보면 아래와 같다.

1. 명령어 해독기  
명령어 레지스터(IR)로부터 들어오는 명령어의 연산 코드를 해독하여 해당 연산을 수행하기 위한 루틴의 시작 주소를 결정한다.
2. 제어 주소 레지스터(CAR)  
다음에 실행할 마이크로명령어의 주소를 저장하는 레지스터이다. 이 주소는 제어 기억장치의 특정 위치를 가리킨다.
3. 제어 기억장치  
마이크로명령어들로 이루어진 마이크로프로그램을 저장하는 내부 기억장치이다.
4. 제어 버퍼 레지스터(CBR)  
제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터이다. 
5. 서브루틴 레지스터(SBR)  
서브루틴이 호출되는 경우에, 현재의 CAR 내용을 일시적으로 저장하는 레지스터이다.
6. 순서제어 모듈  
마이크로명령어의 실행 순서를 결정하는 회로들의 집합이다. 

### 제어 유니트의 동작
인출 사이클 동안 명령어 레지스터로 적재된 명령어 비트들 중에서 '연산 코드(op-code)' 부분은 제어 유니트의 '명령어 해독기'로 들어온다.  
이 연산 코드가 지정하는 연산은 실행 사이클 동안에 '제어 기억장치'에 저장된 해당 루틴을 실행함으로써 수행된다.  
따라서 명령어 해독기는 연산 코드를 이용하여 제어 기억장치 내 해당 실행 사이클 루틴의 주소를 찾아야 한다.   
<br>
실행 사이클 루틴을 찾는 방법에는 여러 방법이 존재하지만, '사상(mapping)' 방식이 가장 대표적이다.  
<br>
<br>

## 4. 기억장치
### 제어 유니트의 기능
CPU가 실행하는 명령어들을 인출하여 해독하고 실행하는 과정이 순차적으로 발생되도록 하기 위해서는 그 순간마다 적절한 제어 신호들이 생성되어 해당 하드웨어 모듈로 보내져야 한다.  
<br>ㅎ
이러한 역할을 담당하는 것이 '제어 유니트(control unit)'이다. 

제어 유니트가 수행하는 주요 기능은 아래와 같다.  
1. 명령어 코드의 해독
2. 명령어 실행에 필요한 제어 신호들의 발생
