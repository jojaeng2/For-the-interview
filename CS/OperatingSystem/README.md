# Operating System

  - [1. 운영체제의 역할](#1-운영체제의-역할)
    - [운영체제란](#운영체제란)
    - [왜 운영체제를 공부하는가](#왜-운영체제를-공부하는가)
    - [멀티 프로세서의 장단점](#멀티-프로세서의-장단점)
    - [Multiprogramming vs Multitasking](#multiprogramming-vs-multitasking)
    - [자원 관리](#자원-관리)
  - [2. 운영체제 구조](2-운영체제-구조)
    - [운영체제 서비스](#운영체제-서비스)
    - [시스템 콜이란](#시스템-콜이란)
    - [응용 프로그램이 운영체제마다 다른이유](#응용-프로그램이-운영체제마다-다른이유)
  - [3. 프로세스](#3-프로세스)
    - [프로세스 개념](#프로세스-개념)
    - [프로세스 제어 블록(PCB)](#프로세스-제어-블록)
    - [프로세스 스케줄링](#프로세스-스케줄링)
    - [프로세스 간 통신](#프로세스-간-통신)
    - [공유 메모리 vs 메시지 전달](#공유-메모리-vs-메시지-전달)

    


</br>

## 1. 운영체제의 역할
### 운영체제란
운영체제는 컴퓨터 하드웨어를 관리하는 소프트웨어이다. 즉, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다.  
<br>
운영체제의 근본적인 책임은 CPU, 메모리, 입출력 장치, 저장장치 등의 하드웨어 자원들을 프로그램에 할당하는 것이다.  

### 왜 운영체제를 공부하는가
모든 코드는 운영체제 위에서 실행되므로, 운영체제 작동방식에 대한 지식은 적절하고 효율적이며 효과적이며 안전한 프로그래밍에 중요하기 때문이다.  

### 멀티 프로세서의 장단점
멀티 프로세서의 주요 장점은 처리량 증가이다. 즉, 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수있다.  
또한 여러 개의 코어를 가지는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬 적은 전력을 사용하는데, 이는 노트북뿐만 아니라 모바일 장치의 중요한 문제이다.

<br> 
그러나, N개의 프로세서가 사용된다고 해서 속도 향상 비율이 N은 아니다.  
프로세서는 컴퓨터 버스, 메모리, 주변 장치 등을 공유하기 때문에 이러한 경합은 추가 프로세서의 예상 이득을 낮춘다.  
<br> 
<br> 

### Multiprogramming vs Multitasking 
운영체제의 가장 중요한 측면 중 하나는 하나의 프로그램이 항상 CPU나 I/O 장치를 바쁘게 유지할 수 없으므로 여러 프로그램을 실행할 수있다는 것이다.  
다중 프로그래밍은 CPU가 항상 프로세스 한개는 실행할 수있도록 프로그램을 수헝하여 CPU 이용률을 높이는 기법이다.  
운영체제는 여러 프로세스를 동시에 메모리에 유지하고, 프로세스 중 하나를 실행한다. 이때 단순히 다른 프로세스로 전환하며 실행하고, 하나의 프로세스가 대기해야 한다면 다른 프로세스로 전환한다.  
<br> 
멀티 태스킹은 다중 프로그래밍의 논리적 확장이다.  
멀티 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만, 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공한다.  

동시에 여러 프로세스를 메모리에 유지하려면, 운영체제의 메모리 관리가 필요하다.  
또한 여러 프로세스가 동시에 실행할 준비가 되면 시스템은 다음에 실행할 프로세스를 선택해야 하는데, 이 결정을 내리는 것이 'CPU 스케줄링'이다. 

### 자원 관리
운영체제는 하드웨어를 관리하는 '자원 관리자'이다. 이때 자원에 속하는 것은 CPU, 메모리, 파일-저장 공간 및 I/O 장치 등이 있다.  

1. 프로세스 관리  
프로그램은 CPU에 의해 명령이 실행되지 않으면 아무것도 할 수없다. 그리고 프로세스는 자기 일을 수행하기 위해 CPU 시간, 메모리, 파일, 그리고 I/O  장치를 포함한 여러 가지 자원을 필요로 한다.  
이러한 자원은 보통 프로세스가 실행되는 동안 할당되고 프로세스가 종료되면 운영체제는 재사용 가능한 자원을 회수한다.  
<br> 
운영체제는 프로세스 관리와 연관해 다음과 같은 책임을 진다.  
(1) 사용자 프로세스와 시스템 프로세스의 생성과 제거  
(2) CPU에 프로세스와 스레드 스케줄링  
(3) 프로세스의 일시 중지와 재수행  
(4) 프로세스 동기화를 위한 기법 제공  
(5)  프로세스 통신을 위한 기법 제공  

2. 메모리 관리  
CPU는 메인 메모리에서만 명령을 적재할 수있으므로, 프로세스를 실행하려면 먼저 메모리에 적재해야한다.  
따라서 메인 메모리는 컴퓨터 시스템의 작동에 중추적인 역할을 할 수있다고 볼 수있다.  
 현대의 컴퓨터는 CPU 이용률과 응답 속도를 개선하기 위해 메모리에 여러개의 프로세스를 유지한다. 그리고 이를 위해서 메모리 기법이 필요하다.  
<br> 
운영체제는 메모리 관리와 연관해 다음과 같은 책임을 진다.  
(1) 메모리의 어느 부분이 현재 사용되고 있으며, 어느 프로세스에 의해 사용되고 있는지를 추적해야 한다.  
(2) 메모리 공간을 할당하고 회수한다.  
(3) 어떤 프로세스를 메모리에 적재하고 제거할 것인가를 결정한다.
3. 파일 시스템 관리  
운영체제는 정보 저장장치에 대한 균일한 논리적 관점을 제공한다.  
대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현하게 된다.  
<br> 
운영체제는 파일 관리를 위해 다음과 같은 일을 담당한다.  
(1) 파일의 생성 및 제거  
(2) 디렉토리 생성 및 제거  
(3) 파일을 보조저장장치로 매핑  


## 2. 운영체제 구조
### 운영체제 서비스
운영체제는 프로그램 실행 환경을 제공한다.  
운영체제마다 제공하는 서비스는 크게 2가지 목적으로 분류할 수있다.  
1. 사용자에게 도움을 주는 목적
2. 시스템의 효율적인 동작을 위한 목적  

가장 먼저 사용자에게 도움을 주기 위한 목적의 운영체제 서비스는 무엇이 있는지 살펴보자.  
이러한 서비스는 프로그래머가 프로그래밍 작업을 더 쉽게 수행할 수 있도록 한다.
<br> 

1. 사용자 인터페이스  
거의 모든 운영체제는 사용자 인터페이스를 제공한다. 가장 일반적으로 GUI가 사용되고, 모바일 시스템은 터치스크린 인터페이스를 제공하기도 한다.  
2. 프로그램 수행  
시스템 프로그램은 메모리에 적재되어 실행될 수있어야 한다. 
3. 입출력 연산  
수행 중인 프로그램은 입출력을 요구할 수있다. 이러한 입출력에는 파일 혹은 입출력 장치가 연관될 수있다.  
입출력 장치는 사용자들이 직접 제어할 수없고 운영체제가 수단을 제공한다.
4. 파일 시스템 조작  
프로그램은 파일을 읽고 쓸 필요가 있다. 또한 이름에 의해 파일을 생성하고 삭제할 수있고 지정된 파일을 찾을 수있어야 한다.  
운영체제는 특정 성능과 성능 특성을 제공하기 위하여 다양한 파일 시스템을 제공한다.
5. 통신  
한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있는 상황이 존재한다.  
이러한 통신은 '공유 메모리'를 통해 구현될 수도 있고, '메시지 전달' 기법을 사용하여 구현될 수있다.
6. 오류 탐지  
운영체제는 모든 가능한 오류를 항상 의식하고 있어야 한다.  
오류를 의식하는 디버깅 설비는 시스템을 효율적으로 사용할 수있는 사용자와 프로그래머의 능력을 향상시킨다.  

<br> 

다음으로 시스템 자체의 효율적인 동작을 보장하기 위한 운영체제 기능들을 살펴보자.  

1. 자원 할당  
다수의 프로세스나 다수의 작업이 동시에 실행될 때, 그들 각각에 자원을 할당해야 한다. 운영체제는 이를 위해 여러 종류의 자원을 관리하는데, 대표적으로 CPU 스케줄링은 운영체제가 제공하는 서비스이다.
2. 로깅  
운영체제는 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 사용하는지 추적하는 서비스를 제공한다.  
이 사용 통계는 컴퓨팅 서비스를 개선하기 위해 시스템을 재구성하고자 하는 시스템 관리자에게 귀중한 자료가 될 수있다.
3. 보호와 보안  
컴퓨터 시스템에 저장된 정보의 소유자는 그 정보의 사용을 통제하길 원한다. 또한 서로 다른 프로세스가 병행하게 수행될 때, 한 프로세스가 다른 프로세스나 운영체제를 방해해서는 안된다.   
이러한 이유로 운영체제는 컴퓨터 시스템을 보호하는 서비스도 제공한다.

### 시스템 콜이란
시스템 콜은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스이다.

### 응용 프로그램이 운영체제마다 다른이유
기본적으로 한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수없다.  
각 운영체제는 시스템 콜 집합을 제공한다. 이 시스템 콜은 응용 프로그램이 사용할 수있도록 운영체제가 제공하는 서비스 집합의 일부이다.  
<br> 
따라서 하나의 API 집합을 호출하도록 설계된 응용 프로그램은 해당 API를 제공하지 않는 운영체제에서는 작동하지 않는다.  

좀더 하드웨어 수준에서 이 문제를 바라보면 다른 어려움이 존재한다.  

- 각 운영체제는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 형식이 있다. 이러한 구성요소는 명시된 구조 형태로 실행 파일 내의 특정 위치에 있어야 운영체제가 파일을 열고 응용 프로그램을 적재하여 올바르게 실행할 수있음을 의미한다.  
- CPU는 다양한 명령어 집합을 가지며, 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수있다.
- 운영체제가 제공하는 시스템 콜은 운영체제마다 다르다.  


## 3. 프로세스
### 프로세스 개념
프로세스는 실행중인 프로그램을 말하며, 현대의 컴퓨팅 시스템에서 작업의 단위를 말한다.  
프로세스의 현재 활동의 상태는 '프로그램 카운터' 값과 '프로세서 레지스터 내용'으로 나타내는데, 프로세스의 메모리 배치는 일반적으로 아래와 같다.  
<br>
![image](https://user-images.githubusercontent.com/76645095/179203467-205f3244-721b-473b-b1d1-c3253fac5050.png)
<br>

- 텍스트 섹션 : 실행 코드
- 데이터 섹션 : 전역 변수
- 힙 섹션 : 프로그램 실행 중에 동적으로 할당되는 메모리
- 스택 섹션 : 함수를 호출할때 임시 데이터 저장장소 

텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행 시간 동안 크기가 변하지 않는다.  
그러나 스택 및 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수있다.  

스택과 힙이 서로의 방향으로 커지기 때문에 운영체제는 이 둘의 영역이 겹치지 않도록 해야한다. 만약 겹친다면 stack overflow, heap overflow를 만날 것이다.  

### 프로세스 제어 블록
각 프로세스는 운영체제에서 '프로세스 제어 블록(PCB)'에 의해 표현된다. 아래의 그림은 PCB를 보여주는 그림이다.  

![image](https://user-images.githubusercontent.com/76645095/179204988-f5bc661e-a143-476e-873f-9197dcf2877c.png)  

프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 아래와 같은 것들이 포함된다.  
<br>
- 프로세스 상태
- 프로그램 카운터
- CPU 레지스터
- CPU 스케줄링 정보
- 입출력 상태 정보

요약하면 PCB는 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소의 역할을 한다.  
또한 다중 스레드를 지원하는 현대 시스템에서 PCB는 각 스레드에 관한 정보를 포함하도록 확장되기도 한다.  

### 프로세스 스케줄링
기본적으로 각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수있다. 단일 CPU 코어가 있는 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수없지만, 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수있다.  
코어보다 많은 프로세스가 있는 경우 초과 프로세스는 코어가 사용 가능해지고 다시 스케줄될 때까지 기다려야 한다.  

#### 스케줄링 큐
프로세스가 시스템에 들어가면 '준비 큐'에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다리며, 이 큐는 일반적으로 연결 리스트로 저장된다.  
준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고, 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.  

또한 '대기 큐'라는 것도 존재하는데, 이는 프로세스에 CPU 코어가 할당되었을때, I/O 요청의 완료와 같은 특정 이벤트를 기다리는 큐이다. 프로세스가 스케줄링 큐에 올라가는 흐름은 아래와 같다.  
<br>
새 프로세스는 처음에 준비 큐에 놓인다. 그리고 프로세스는 실행을 위해 선택되거나 기다린다.  
프로세스에 CPU 코어가 할당되고, 실행 상태가 되면 아래와 같은 여러 이벤트 중 하나가 발생할 수있다. 
- 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓인다.
- 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수있다.  
- 인터럽트되어 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아간다.  

#### 문맥 교환(Context Switch)  
인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏너 다른 루틴을 실행하는 것이다.  
인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 '문맥'을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.  
<br>
이는 결국 프로세스를 중단했다가 재개하는 작업이며, 문맥은 PCB로 표현된다.  
CPU 코어를 다른 프로세스로 교환하려면, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다.  
이 작업을 '문맥 교환(Context Switch)'라고 부른다.  
<br>
문맥 교환이 진행될 동안 CPU는 아무런 유용한 일을 못하기 때문에 문맥 교환 시간은 순수한 오버헤드가 된다. 

#### 프로세스 간 통신
운영체제 내에서 실행되는 프로세스들은 2가지로 분류할 수있다.

- 독립적 프로세스 : 다른 프로세스들과 데이터를 공유하지 않는 프로세스이다.  
- 협력적 프로세스 : 다른 프로세스들에 영향을 주거나 받는 프로세스이다.

프로세스가 협력을 허용하는 환경을 제공하는 데는 몇가지 이유가 있다.
- 정보 공유 : 여러 응용 프로그램이 동일한 정보에 흥미를 느낄 수있으므로, 정보를 병행적으로 접근할 수 있는 환경을 제공해야 한다.
- 계산 가속화 : 특정 태스크를 빨리 실행하고자 한다면, 우리는 태스크를 서브태스크로 나누어 이들 각각이 다른 서브태스크들과 병렬로 실행되게 해야 한다. 
- 모듈성 : 시스템 기능을 별도의 프로세스들 또는 스레드들로 나누어, 모듈식 형태로 시스템을 구성하기를 원할 수 있다.

협력적 프로세스들은 데이터를 교환할 수있는 '프로세스 간 통신(IPC)' 기법이 필요하다.  
IPC를 위한 기본적인 모델로는 아래와 같은 2가지 모델이 있다. 

- 공유 메모리
- 메시지 전달


#### 공유 메모리 vs 메시지 전달
공유 메모리가 메시지 전달 기법보다 빠르다.  
메시지 전달 시스템은 신호를 생성하고 전달해야 하는 반면, 공유 메모리는 메모리에 바로 접근해서 사용하면 되기 때문이다.  

만약 공통 데이터를 자주 접근하는 경우 공유 메모리가 효율성이 높고, 분산 시스템에서 네트워크를 통해 다른 프로세스와 통신하는 경우 메시지 전달이 더 적절하다. 